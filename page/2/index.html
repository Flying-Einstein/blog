<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>以技术之名</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="为信仰而生">
<meta property="og:type" content="website">
<meta property="og:title" content="以技术之名">
<meta property="og:url" content="http://iamlay.com/page/2/index.html">
<meta property="og:site_name" content="以技术之名">
<meta property="og:description" content="为信仰而生">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ray">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="以技术之名" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">以技术之名</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://iamlay.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-week16" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/19/week16/" class="article-date">
  <time datetime="2020-04-19T12:45:27.000Z" itemprop="datePublished">2020-04-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/19/week16/">以技术之名周报04#Sign in with Apple 设计原则| 2020-04-19</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="使用Apple提供的Button"><a href="#使用Apple提供的Button" class="headerlink" title="使用Apple提供的Button"></a>使用Apple提供的Button</h3><p>当你使用系统提供的API创建Button的时候，能够获得以下优势：</p>
<ol>
<li>能够确保Button使用了苹果认可的title、font、color 和 style</li>
<li>能够确保在你修改Button的Style的时候，Button的Content有一个理想的位置</li>
<li>Button的title能够跟自动转换成设备手机选择的Language</li>
<li>支持配置圆角以满足你自己UI的风格（iOS、MacOS、Web）</li>
</ol>
<p>对开发者而言，可以看这些使用引导<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/authenticationservices/asauthorizationappleidbutton">ASAuthorizationAppleIDButton</a> (iOS, macOS, and tvOS), <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/watchkit/wkinterfaceauthorizationappleidbutton">WKInterfaceAuthorizationAppleIDButton</a> (watchOS), and <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/signinwithapplejs/displaying_and_configuring_sign_in_with_apple_buttons">Displaying and Configuring Sign in with Apple Buttons</a> (web).</p>
<p>系统提供的Button 的Title有几种文案。根据你使用的平台，选择最合适的文案。</p>
<p>下面几种Button Title都可以在iOS、macOS、和tvOS中使用，但是只有Sign in with Apple 和 Continue with Apple 可以在Web中使用</p>
<p><img src="/SignWithApple01.png"></p>
<p>对watchOS，系统提供的Title只有一个 <code> Sign in</code></p>
<p><img src="/SignWithApple02.png"></p>
<p>依赖于不同的平台，系统提供了三种外观的Button，分别是白色（white）、有边框的白色（white with an outline）、黑色（black）。根据放置Button的背景颜色，选择最合Button样式。</p>
<h4 id="白色"><a href="#白色" class="headerlink" title="白色"></a>白色</h4><p>白色可以在任何平台使用（包括Web）,当背景是黑色或者其他深色时，选择白色会有更好的表现力</p>
<p><img src="/SignWithApple03.png"></p>
<h4 id="白色带边框"><a href="#白色带边框" class="headerlink" title="白色带边框"></a>白色带边框</h4><p>白色带边框的Button可以在iOS、macOS、和Web上面使用，当背景是白色或浅色背景的时候，背景和Button的填充色对比是不够强烈的，通过添加边框可以提升表现力。当背景是深色的时候，不要使用这种风格，深色会使得这种风格变得混乱。</p>
<p><img src="/SignWithApple04.png"></p>
<h4 id="黑色"><a href="#黑色" class="headerlink" title="黑色"></a>黑色</h4><p>黑色可以在任何平台使用（包括Web）,当背景是白色或者其他浅色时，选择黑色会有更好的表现力</p>
<p><img src="/SignWithApple05.png"><br>不像其他平台上的黑色风格的Button，在watchOS上，黑色风格的Button是非全黑的填充色，和watchOS全黑色的背景做对比。watchOS上Button用系统定义的黑灰样式。</p>
<p><img src="/SignWithApple06.png"></p>
<h4 id="Button的大小和圆角"><a href="#Button的大小和圆角" class="headerlink" title="Button的大小和圆角"></a>Button的大小和圆角</h4><p>调整Button的圆角以匹配App中其他登录Button的风格。默认情况下， Sign in with Apple的Button是没有圆角的。在iOS、macOS、Web中，可以通过修改圆角的半径，生成直角或者药丸状的Button。</p>
<p><img src="/SignWithApple07.png"></p>
<p><strong>iOS、macOS 、Web中使用的Button，必须有一个最小的的Size和外边距</strong>。值得注意的是，依赖于文本的本地化，Button的长度或许很长。下面的值可以做作为设计原则：</p>
<table>
<thead>
<tr>
<th>Minimum width</th>
<th>Minimum height</th>
<th>Minimum margin</th>
</tr>
</thead>
<tbody><tr>
<td>140pt (140px @1x, 280px @2x)</td>
<td>30pt (30px @1x, 60px @2x)</td>
<td>1&#x2F;10 of the button’s height</td>
</tr>
</tbody></table>
<h3 id="创建一个自定义的-Sign-in-with-Apple-Button"><a href="#创建一个自定义的-Sign-in-with-Apple-Button" class="headerlink" title="创建一个自定义的 Sign in with Apple Button"></a>创建一个自定义的 Sign in with Apple Button</h3><p>如果你有需要的话，可以在iOS、macOS、或者Web平台上自己创建一个自定义的Sign in with Apple Button 。比如：或许你支持多种登录方式，你想展示<code>Left-Aligned Logo</code> Button或者<code>Logo-Only</code> Button。</p>
<p><img src="/SignWithApple08.png"></p>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/design/resources/">Apple Design Resources </a>提供了一些美术资源，你可以使用这些美术资源自定义Sign in with Apple Button。这些资源包括PNG、SVG和PDF三种格式，并且包含黑白两种表现形式。下面是<code>Logo-Only</code> Button的两个例子，每个Logo都添加了富有表现力的背景色</p>
<p><img src="/SignWithApple09.png"></p>
<p>所有下载的Logo文件都包含一个内边距，这样在Button中放置logo更加容易</p>
<ol>
<li><code>Left-Aligned Logo</code>文件包含一个垂直方向上的内边距，能够确保Logo在Button中有一个合适的占比，水平方向上的内边距也为Logo和Button的左边距、Logo和Button的title之间提供了一个最小边距。</li>
<li><code>Logo-Only</code>文件包含一个水平和垂直方向上的内边距，确保了Logo在Button中有一个合适的占比</li>
</ol>
<p>使用<code>Logo-Only</code>文件的时候,需要遵循以下原则：</p>
<ol>
<li>不要仅仅使用 Apple Logo  自己作为一个Button</li>
<li>Logo文件的高度要和Button的高度保持一致</li>
<li>不要剪切Logo文件</li>
<li>不要添加垂直方向的内边距</li>
<li>Logo文件不要使用自己定义的颜色</li>
</ol>
<h4 id="Left-Aligned-Logo-Buttons"><a href="#Left-Aligned-Logo-Buttons" class="headerlink" title="Left-Aligned Logo Buttons"></a>Left-Aligned Logo Buttons</h4><p>根据你的Button的高度选择合适的Logo文件。因为PDF和SVG是矢量图，你可以在任何高度的Button中使用这两种文件。而PNG文件只能在高度为44的Button中使用，这是iOS中Button的默认高度。</p>
<p>Title要使用系统字体(Sign in with Apple、Sign up with Apple、 Continue with Apple)：为了统一，你自定义的Button的高度和Title应该和系统使用的<code>保持一样的比例</code>。Title应该占据Button高度的43%，换言之Button的高度应该是Title Font大小的233%。下面两个例子展示了这种比例：</p>
<p><img src="/SignWithApple10.png"></p>
<p><strong>保持Title的大写的风格</strong>所有Title的首字母都是大写的（Sign or Continue — and Apple），其他的字母是小写的。切不可改变这种风格。</p>
<p><strong>保持Title和Logo和Button在垂直方向上对齐</strong>：为了做到这一点，Title和Button的中部在垂直方向上对齐，然后添加Logo图片，确保图片的高度和Button的高度一致。因为Logo图片本身具有顶部和底部的内边距，垂直对齐Button的Title能够确保Title和Logo在Button中占据合适的比例。</p>
<p><strong>如果有需要可以嵌入Logo</strong> 如果你需要将苹果的Logo和其他的认证的logo对齐，可以将Logo左侧嵌入</p>
<p><strong>Title和Button的右边有一个最小内边距</strong>  边距至少占据Button宽度的8%</p>
<p><strong>Button有一个最小的size，且Button有一个内边距</strong> ：因为文本的本地化，Button的长度可能很长。参考下面的设计原则：</p>
<table>
<thead>
<tr>
<th>Minimum width</th>
<th>Minimum height</th>
<th>Minimum margin</th>
</tr>
</thead>
<tbody><tr>
<td>140pt (140px @1x, 280px @2x)</td>
<td>30pt (30px @1x, 60px @2x)</td>
<td>1&#x2F;10 of the button’s height</td>
</tr>
</tbody></table>
<h4 id="Logo-Only-Buttons"><a href="#Logo-Only-Buttons" class="headerlink" title="Logo-Only Buttons"></a>Logo-Only Buttons</h4><p><strong>根据你的Button的高度选择合适的Logo文件</strong>。因为PDF和SVG是矢量图，你可以在任何高度的Button中使用这两种文件。而PNG文件只能在高度为44的Button中使用。</p>
<p><strong>不要为Logo-Only图片添加水平方向上的内边距</strong>   Logo-only的Button是1:1的比例，下载的Logo-Only文件已经有了合适的内边距</p>
<p><strong>用mask(遮罩)改变Logo-only图片的形状</strong>  例如 Sign in with Apple使用用圆形或者椭圆矩形的Button。不要为了减小内边距剪切Apple提供的美术资源，也不要只使用Apple Logo。</p>
<p><img src="/SignWithApple11.png"></p>
<p><strong>Button有一个最小的内边距</strong>  内边距至少为Button高度的1&#x2F;10</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://iamlay.com/2020/04/19/week16/" data-id="clfj8cp2t0022fbf36ejs7gq3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-OCCodeAnalysis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/13/OCCodeAnalysis/" class="article-date">
  <time datetime="2020-04-13T01:55:54.000Z" itemprop="datePublished">2020-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/13/OCCodeAnalysis/">如何在OC中进行源码分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Part01-获取objc-runtime的源码"><a href="#Part01-获取objc-runtime的源码" class="headerlink" title="Part01-获取objc-runtime的源码"></a>Part01-获取objc-runtime的源码</h3><p><a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/">objc-runtime的源码地址</a></p>
<p>注意：⚠️⚠️⚠️，objc-runtime的源码的新旧程度并不是按照时间进行排序，而是按照包的大小进行的排序，一般可以理解为包最大的即为最新的源码</p>
<p>但是官网的runtime代码是无法直接运行的，如果想直接运行可以下载<a target="_blank" rel="noopener" href="https://github.com/RetVal">RetVal</a>处理过的<a target="_blank" rel="noopener" href="https://github.com/RetVal/objc-runtime">源代码</a></p>
<h3 id="Part02-将OC代码编译成C-代码"><a href="#Part02-将OC代码编译成C-代码" class="headerlink" title="Part02-将OC代码编译成C++代码"></a>Part02-将OC代码编译成C++代码</h3><ol>
<li>找到需要编译成C++代码的OC文件，这里我们拿<code>main.m</code>来举例</li>
</ol>
<p><img src="/OCCodeAnalysis01.png" alt="image"></p>
<ol start="2">
<li>进入到main.m所在的文件夹，执行：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//-fobjc-arc表示编译需要支持ARC特性。</span><br><span class="line">//-framework Foundation表示引用Foundation框架，这个框架中定义了很多基本的类，例如字符串、数组、字典等等。</span><br><span class="line">//后面的 mian.m 就是待编译的源代码文件名。</span><br><span class="line">//-o main 表示输出的可执行文件的文件名是 main。</span><br><span class="line"></span><br><span class="line">clang -fobjc-arc -framework Foundation main.m -o main</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>得到执行文件，双击可以看到执行结果</p>
<p><img src="/OCCodeAnalysis02.png" alt="image"></p>
<ol start="3">
<li>生成main.m的cpp文件main.cpp，main.cpp就是编译器对main.m进行转换的结果，执行：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m</span><br></pre></td></tr></table></figure>
如果在执行<code>执行 clang -rewrite-objc main.m</code>是报错的，例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main.m:9:9: fatal error: &#x27;UIKit/UIKit.h&#x27; file not found</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">        ^~~~~~~~~~~~~~~</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure>
<p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/xxxxx.m</span><br></pre></td></tr></table></figure>
<h3 id="Part03-根据C-代码，结合objc-runtime源码进行分析"><a href="#Part03-根据C-代码，结合objc-runtime源码进行分析" class="headerlink" title="Part03-根据C++代码，结合objc-runtime源码进行分析"></a>Part03-根据C++代码，结合objc-runtime源码进行分析</h3><p>执行完上面的指令，生成了相关文件的C++ 代码，C++代码用到了objc-runtime源码，所以要进入到objc-runtime源码，探索本质。例如下面是main.m编译成main.cpp文件时，-(void)eat生成的C ++代码。标出来的代码都是objc-runtime中的源代码</p>
<p><img src="/OCCodeAnalysis03.png" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://iamlay.com/2020/04/13/OCCodeAnalysis/" data-id="clfj8cp2l0017fbf316oec4zz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-week15" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/12/week15/" class="article-date">
  <time datetime="2020-04-12T11:55:37.000Z" itemprop="datePublished">2020-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/12/week15/">以技术之名周报03#AOP| 2020-04-12</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Part01-什么是AOP"><a href="#Part01-什么是AOP" class="headerlink" title="Part01-什么是AOP?"></a>Part01-什么是AOP?</h3><blockquote>
<p>面向切面的程序设计（Aspect-oriented programming，AOP，又译作面向方面的程序设计、剖面导向程序设计）是计算机科学中的一种程序设计思想，旨在将横切关注点与业务主体进行进一步分离，以提高程序代码的模块化程度。通过在现有代码基础上增加额外的通知（Advice）机制，能够对被声明为“切点（Pointcut）”的代码块进行统一管理与装饰，如“对所有方法名以‘set*’开头的方法添加后台日志”。该思想使得开发人员能够将与代码核心业务逻辑关系不那么密切的功能（如日志功能）添加至程序中，同时又不降低业务代码的可读性。</p>
</blockquote>
<h3 id="Part02-AOP一个使用场景：埋点"><a href="#Part02-AOP一个使用场景：埋点" class="headerlink" title="Part02-AOP一个使用场景：埋点"></a>Part02-AOP一个使用场景：埋点</h3><p>互联网进入到下半场，用户也由增量进入到存量时代。通过统计用户操作行为了解用户的偏好，结合大数据分析，可以方便公司更加合理的作出决策更好的吸引客户、留住客户。对任何一个主流的APP来讲，都会存在大量的埋点来统计用户的行为。埋点功能不属于业务逻辑，埋点代码和业务代码混合在一块会严重污染业务代码，且埋点的代码会分散到整个工程。面向切面编程是解决这种问题一个很好的方案，其原理就是在不更改正常业务处理流程的前提下，动态生成一个代理类，从而实现对目标对象嵌入附加的操作。</p>
<h3 id="Part03-iOS实现AOP的原理"><a href="#Part03-iOS实现AOP的原理" class="headerlink" title="Part03-iOS实现AOP的原理"></a>Part03-iOS实现AOP的原理</h3><p>利用OC的动态性，通过wizzling method 改变目标函数的 selector 所指向的实现，然后在新的实现中实现附加的操作，完成之后再回到原来的处理逻辑。OC是一门动态语言，在OC中执行一个方法的时候实际上是在发送一条消息给接受对象<code>[receiver message]</code>。完整的过程是根据<code>message</code>生成一个选择子<code>selector</code>，然后根据<code>selector</code>找到指向函数的的具体的实现的指针<code>IMP</code>，然后找到真正的函数执行逻辑。OC的这种处理流程为我们动态修改函数的实现提供了可能，在运行时，只要我们改变selector和IMP的对应关系，我们就可以在执行<code>[receiver message]</code>时进入到新的函数实现。</p>
<h3 id="Part04-iOS实现AOP的一个成熟的开源框架：Aspects"><a href="#Part04-iOS实现AOP的一个成熟的开源框架：Aspects" class="headerlink" title="Part04- iOS实现AOP的一个成熟的开源框架：Aspects"></a>Part04- iOS实现AOP的一个成熟的开源框架：Aspects</h3><h4 id="Aspects的实现思路"><a href="#Aspects的实现思路" class="headerlink" title="Aspects的实现思路"></a>Aspects的实现思路</h4><p>Aspects是利用 oc 自己的消息转发机制进行转发，在解释这个过程之前，我们先看一下消息是怎么找到对应的IMP的<img src="/week1501.jpg" alt="image"></p>
<p>从上面我们可以发现，在发消息的时候，如果 <code>selector</code> 有对应的 <code>IMP</code> ,则直接执行，如果没有，oc 给我们提供了几个可供补救的机会，依次有 <code>resolveInstanceMethod</code> 、<code>forwardingTargetForSelector</code>、<code>forwardInvocation</code>。Aspects 之所以选择在 <code>forwardInvocation </code>这里处理是因为，这几个阶段特性都不太一样：<code>resolvedInstanceMethod </code>适合给类&#x2F;对象动态添加一个相应的实现，<code>forwardingTargetForSelector </code>适合将消息转发给其他对象处理,相对而言，<code>forwardInvocation</code> 是里面最灵活，最能符合需求的。因此 Aspects 的方案就是，对于待<code> hook</code> 的 <code>selector</code>，将其指向 <code>objc_msgForward / _objc_msgForward_stret </code>,同时生成一个新的 <code>aliasSelector</code> 指向原来的 <code>IMP</code>，并且 <code>hook</code> 住 <code>forwardInvocation</code> 函数，使他指向自己的实现。按照上面的思路，当被 <code>hook </code>的 <code>selector</code> 被执行的时候，首先根据 <code>selector </code>找到了<code>objc_msgForward / _objc_msgForward_stret</code>,而这个会触发消息转发，从而进入 <code>forwardInvocation</code>。同时由于 <code>forwardInvocation</code> 的指向也被修改了，因此会转入新的<code> forwardInvocation</code> 函数，在里面执行需要嵌入的附加代码，完成之后，再转回原来的<code> IMP</code>。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><p>从头文件中可以看到使用aspects有两种使用方式：(1)类方法 ；(2)实例方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">                           withOptions:(AspectOptions)options</span><br><span class="line">                            usingBlock:(id)block</span><br><span class="line">                                 error:(NSError **)error;</span><br><span class="line">/// Adds a block of code before/instead/after the current `selector` for a specific instance.</span><br><span class="line">- (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">                           withOptions:(AspectOptions)options</span><br><span class="line">                            usingBlock:(id)block</span><br><span class="line">                                 error:(NSError **)error;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>两者的主要原理基本差不多，这里不做一一介绍，只是以实例方法为例进行说明。在介绍之前，先介绍里面几个重要的数据结构：</p>
<h5 id="AspectOptions"><a href="#AspectOptions" class="headerlink" title="AspectOptions"></a>AspectOptions</h5><p> block 执行的时机，也就是额外操作的执行时机，它可以在原始函数执行之前，也可以是执行之后，甚至可以完全替换掉原来的逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, AspectOptions) &#123;</span><br><span class="line">    AspectPositionAfter   = 0,            /// Called after the original implementation (default)</span><br><span class="line">    AspectPositionInstead = 1,            /// Will replace the original implementation.</span><br><span class="line">    AspectPositionBefore  = 2,            /// Called before the original implementation.</span><br><span class="line">    AspectOptionAutomaticRemoval = 1 &lt;&lt; 3 /// Will remove the hook after the first execution.</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="AspectsContainer"><a href="#AspectsContainer" class="headerlink" title="AspectsContainer"></a>AspectsContainer</h5><p>一个对象或者类的所有的 Aspects 整体情况:一个对象和类可能有多个Aspect，每个Aspect的执行的时机都是不一样的，AspectsContainer存储了这个类或对象全部的Aspect</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Tracks all aspects for an object/class.</span><br><span class="line">@interface AspectsContainer : NSObject</span><br><span class="line">- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;</span><br><span class="line">- (BOOL)removeAspect:(id)aspect;</span><br><span class="line">- (BOOL)hasAspects;</span><br><span class="line">@property (atomic, copy) NSArray *beforeAspects;</span><br><span class="line">@property (atomic, copy) NSArray *insteadAspects;</span><br><span class="line">@property (atomic, copy) NSArray *afterAspects;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h5 id="AspectIdentifier"><a href="#AspectIdentifier" class="headerlink" title="AspectIdentifier"></a>AspectIdentifier</h5><p>一个 Aspect 的具体内容，这里主要包含了单个的 aspect 的具体信息，包括执行时机，要执行 block 所需要用到的具体信息：包括方法签名、参数等等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface AspectIdentifier : NSObject</span><br><span class="line">+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error;</span><br><span class="line">- (BOOL)invokeWithInfo:(id&lt;AspectInfo&gt;)info;</span><br><span class="line">@property (nonatomic, assign) SEL selector;</span><br><span class="line">@property (nonatomic, strong) id block;</span><br><span class="line">@property (nonatomic, strong) NSMethodSignature *blockSignature;</span><br><span class="line">@property (nonatomic, weak) id object;</span><br><span class="line">@property (nonatomic, assign) AspectOptions options;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h5 id="AspectInfo"><a href="#AspectInfo" class="headerlink" title="AspectInfo"></a>AspectInfo</h5><p>一个 Aspect 执行环境，主要是 NSInvocation 信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface AspectInfo : NSObject &lt;AspctInfo&gt;</span><br><span class="line">- (id)initWithInstance:(__unsafe_unretained id)instance invocation:(NSInvocation *)invocation;</span><br><span class="line">@property (nonatomic, unsafe_unretained, readonly) id instance;</span><br><span class="line">@property (nonatomic, strong, readonly) NSArray *arguments;</span><br><span class="line">@property (nonatomic, strong, readonly) NSInvocation *originalInvocation;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="代码流程"><a href="#代码流程" class="headerlink" title="代码流程"></a>代码流程</h4><p>有了上面的了解，我们就能更好的分析整个 apsects 的执行流程。添加一个 aspect 的关键流程如下图所示：</p>
<p><img src="/week1502.jpg" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tatic id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) &#123;</span><br><span class="line">    ...</span><br><span class="line">    __block AspectIdentifier *identifier = nil;</span><br><span class="line">    aspect_performLocked(^&#123;</span><br><span class="line">        if (aspect_isSelectorAllowedAndTrack(self, selector, options, error)) &#123;//1判断能否hook</span><br><span class="line">            ...//2 记录数据结构</span><br><span class="line">            aspect_prepareClassAndHookSelector(self, selector, error);//3 swizzling</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return identifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="判断能否被-hook"><a href="#判断能否被-hook" class="headerlink" title="判断能否被 hook"></a>判断能否被 hook</h5><p>对于对象实例而言，这里主要是根据黑名单，比如 retain forwardInvocation 等这些方法在外部是不能被 hook ,(对于类对象还要确保同一个类继承关系层级中，只能被 hook 一次，因此这里需要判断子类，父类有没有被 hook，之所以做这样的实现，主要是为了避免出现死循环的出现，这里有相关的讨论)。如果能够 hook，则继续下面的步骤。</p>
<h5 id="swizzling-method"><a href="#swizzling-method" class="headerlink" title="swizzling method"></a>swizzling method</h5><p>这是真正的核心逻辑，<code>swizzling method </code>主要有两部分，一个是对对象的 <code>forwardInvocation </code>进行 <code>swizzling</code>,另一个是对传入的 <code>selector</code> 进行 <code>swizzling</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) &#123;</span><br><span class="line">    Class klass = aspect_hookClass(self, error); //1  swizzling forwardInvocation</span><br><span class="line">    Method targetMethod = class_getInstanceMethod(klass, selector);</span><br><span class="line">    IMP targetMethodIMP = method_getImplementation(targetMethod);</span><br><span class="line">    if (!aspect_isMsgForwardIMP(targetMethodIMP)) &#123;//2  swizzling method</span><br><span class="line">       ...//</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="swizzling-forwardInvocation"><a href="#swizzling-forwardInvocation" class="headerlink" title="swizzling forwardInvocation:"></a>swizzling forwardInvocation:</h6><p><code>aspect_hookClass</code> 函数主要 <code>swizzling </code>类&#x2F;对象的 <code>forwardInvocation</code> 函数，<code>aspects </code>的真正的处理逻辑都是在 <code>forwradInvocation</code> 函数里面进行的。对于对象实例而言，源代码中并没有直接 swizzling 对象的 <code>forwardInvocation </code>方法，而是动态生成一个当前对象的子类，并将当前对象与子类关联,然后替换子类的<code> forwardInvocation</code> 方法(这里具体方法就是调用了 <code>object_setClass(self, subclass) </code>,将当前对象 <code>isa </code>指针指向了<code> subclass</code> ,同时修改了<code>subclass</code>以及其 <code>subclass metaclass</code> 的 <code>class</code> 方法,使他返回当前对象的 <code>class</code>。它的原理有点类似 <code>kvo</code> 的实现，它想要实现的效果就是，将当前对象变成一个 <code>subclass</code> 的实例，同时对于外部使用者而言，又能把它继续当成原对象在使用，而且所有的 <code>swizzling </code>操作都发生在子类，这样做的好处是你不需要去更改对象本身的类，也就是，当你在<code>remove aspects</code>的时候，如果发现当前对象的 <code>aspect</code> 都被移除了，那么，你可以将 isa 指针重新指回对象本身的类，从而消除了该对象的 <code>swizzling</code> ,同时也不会影响到其他该类的不同对象)。对于每一个对象而言，这样的动态对象只会生成一次，这里<code>aspect_swizzlingForwardInvocation</code>将使得 <code>forwardInvocation</code> 方法指向 <code>aspects </code>自己的实现逻辑 ,具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static Class aspect_hookClass(NSObject *self, NSError **error) &#123;</span><br><span class="line">     ...</span><br><span class="line">     //生成动态子类，并swizzling forwardInvocation方法</span><br><span class="line">     subclass = objc_allocateClassPair(baseClass, subclassName, 0); </span><br><span class="line">     aspect_swizzleForwardInvocation(subclass);//swizzling forwardinvation方法</span><br><span class="line">     objc_registerClassPair(subclass);</span><br><span class="line">      ...</span><br><span class="line">     object_setClass(self, subclass);//将当前self设置为子类，这里其实只是更改了self的isa指针而已</span><br><span class="line">     return subclass;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">static void aspect_swizzleForwardInvocation(Class klass) &#123;</span><br><span class="line">     ...</span><br><span class="line">    IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:),     (IMP)__ASPECTS_ARE_BEING_CALLED__, &quot;v@:@&quot;);</span><br><span class="line">    if (originalImplementation) &#123;</span><br><span class="line">         class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName),        originalImplementation, &quot;v@:@&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于子类本身并没有实现 <code>forwardInvocation</code> ，隐藏返回的 <code>originalImplementation</code> 将为空值，所以也不会生成 <code>NSSelectorFromString(AspectsForwardInvocationSelectorName) </code>。</p>
<h6 id="swizzling-selector"><a href="#swizzling-selector" class="headerlink" title="swizzling selector"></a>swizzling selector</h6><p>当 <code>forwradInvocation</code> 被<code>hook</code>之后，接下来，将对传入的<code>selector</code>进行<code> hook</code> ，这里的做法是，将<code> selector</code> 指向了转发 <code>IMP </code>，同时生成一个 <code>aliasSelector</code> ，指向了原来的<code>IMP</code>,同时为防止重复<code> hook</code> ,做了一个判断，如果发现 <code>selector</code> 已经指向了转发<code> IMP</code> ,那就就不需要进行交换了，代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tatic void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) &#123;</span><br><span class="line">     ...</span><br><span class="line">     Method targetMethod = class_getInstanceMethod(klass, selector);</span><br><span class="line">     IMP targetMethodIMP = method_getImplementation(targetMethod);</span><br><span class="line">     if (!aspect_isMsgForwardIMP(targetMethodIMP)) &#123;</span><br><span class="line">     ...</span><br><span class="line">     SEL aliasSelector = aspect_aliasForSelector(selector);//generator aliasSelector</span><br><span class="line">     if (![klass instancesRespondToSelector:aliasSelector]) &#123;</span><br><span class="line">          __unused BOOL addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding); </span><br><span class="line">     &#125;</span><br><span class="line">     class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(self, selector), typeEncoding);// point to   _objc_msgForward</span><br><span class="line">   ...</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="handle-ForwardInvocation"><a href="#handle-ForwardInvocation" class="headerlink" title="handle ForwardInvocation"></a>handle ForwardInvocation</h6><p>基于上面的代码分析知道，转发最终的逻辑代码最终转入 <code>__ASPECTS_ARE_BEING_CALLED__</code> 函数的处理中。这里，需要处理的部分包括额外处理代码（如打点代码）以及最终重新转会原来的<code>selector</code>所指向的函数，其实现代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static void __ASPECTS_ARE_BEING_CALLED__(__unsafe_unretained NSObject *self, SEL selector, NSInvocation *invocation) &#123;</span><br><span class="line">...</span><br><span class="line">     // Before hooks.  原来逻辑之前执行</span><br><span class="line">    aspect_invoke(classContainer.beforeAspects, info);</span><br><span class="line">    aspect_invoke(objectContainer.beforeAspects, info);</span><br><span class="line">    // Instead hooks.</span><br><span class="line">    BOOL respondsToAlias = YES;</span><br><span class="line">    if (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) &#123;//是否需要替换掉原来的路基</span><br><span class="line">         aspect_invoke(classContainer.insteadAspects, info);</span><br><span class="line">         aspect_invoke(objectContainer.insteadAspects, info);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Class klass = object_getClass(invocation.target);</span><br><span class="line">        do &#123;</span><br><span class="line">              if ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) &#123;</span><br><span class="line">                    [invocation invoke];//根据aliasSelector找到原来的逻辑并执行</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;while (!respondsToAlias &amp;&amp; (klass = class_getSuperclass(klass)));</span><br><span class="line">     &#125;</span><br><span class="line">    // After hooks.  原来逻辑之后执行</span><br><span class="line">     aspect_invoke(classContainer.afterAspects, info);</span><br><span class="line">     aspect_invoke(objectContainer.afterAspects, info);</span><br><span class="line">    // If no hooks are installed, call original implementation (usually to throw an exception)</span><br><span class="line">     if (!respondsToAlias) &#123;//找不到aliasSelector的IMP实现，没有找到原来的逻辑，进行消息转发</span><br><span class="line">          invocation.selector = originalSelector;</span><br><span class="line">          SEL originalForwardInvocationSEL = NSSelectorFromString(AspectsForwardInvocationSelectorName);</span><br><span class="line">          if ([self respondsToSelector:originalForwardInvocationSEL]) &#123;</span><br><span class="line">               ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, originalForwardInvocationSEL, invocation);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              [self doesNotRecognizeSelector:invocation.selector];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;                     </span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依次处理 <code>before/instead/after hook</code> 以及真正函数实现。如果没有找到原始的函数实现，还需要进行转发操作。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://wereadteam.github.io/2016/06/30/Aspects/">面向切面编程之 Aspects 源码解析及应用</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://iamlay.com/2020/04/12/week15/" data-id="clfj8cp2s001zfbf32q391ye7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-week14" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/02/week14/" class="article-date">
  <time datetime="2020-04-02T11:41:49.000Z" itemprop="datePublished">2020-04-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%91%A8%E6%8A%A5/">周报</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/02/week14/">以技术之名周报02#X86-汇编| 2020-04-05</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Part01-知识准备"><a href="#Part01-知识准备" class="headerlink" title="Part01 - 知识准备"></a>Part01 - 知识准备</h4><p>在介绍汇编之前，我们首先应该搞清楚什么是机器语言？什么是汇编语言？什么是高级语言？</p>
<p><strong>机器语言：</strong></p>
<blockquote>
<p>机器语言是用二进制代码表示的计算机能直接识别和执行的一种机器指指令系统令的集合。</p>
</blockquote>
<p><strong>汇编语言：</strong></p>
<blockquote>
<p>汇编语言是任何一种用于电子计算机、微处理器、微控制器，或其他可编程器件的低级语言。在不同的设备中，汇编语言对应着不同的机器语言指令集。一种汇编语言专用于某种计算机系统结构，而不像许多高级语言，可以在不同系统平台之间移植。汇编语言使用助记符（Mnemonics）来代替和表示特定低级机器语言的操作。</p>
</blockquote>
<p><strong>高级语言:</strong></p>
<blockquote>
<p>高级编程语言是高度封装了的编程语言，与低级语言相对。它是以人类的日常语言为基础的一种编程语言，使用一般人易于接受的文字来表示，有较高的可读性，以方便对电脑认知较浅的人亦可以大概明白其内容。比如：C、C++、Swift、Java…</p>
</blockquote>
<p>用一张图来解释这三种语言之间的关系：</p>
<p><img src="/Assembly01.png" alt="image"></p>
<h4 id="Part02-编译器：LLVM"><a href="#Part02-编译器：LLVM" class="headerlink" title="Part02 - 编译器：LLVM"></a>Part02 - 编译器：LLVM</h4><p>汇编严重依赖硬件设备, <code>iOS</code>模拟器使用<code>AT&amp;T</code>格式汇编(因为 <code>Mac</code> 是基于 <code>Unix</code> 开发的), <code>iOS</code> 真机使用ARM汇编<br>。</p>
<p><code>Xcode</code>内置的编译器是<code>LLVM</code>，<code>LLVM</code> 是一个著名的编译器, 由大神 <code>Chris Lattner </code>开发, 可用于常规编译器, JIT编译器, 汇编器, 调试器, 静态分析工具等一系列跟编程语言相关的工作。</p>
<h5 id="LLVM-的编译架构分为三个阶段"><a href="#LLVM-的编译架构分为三个阶段" class="headerlink" title="LLVM 的编译架构分为三个阶段"></a>LLVM 的编译架构分为三个阶段</h5><ol>
<li>前端：进行语法分析, 语义分析, 生成中间代码。实际上在 Xcode 中写代码的时候会实时提示错误就是因为持续在调用 LLVM 的前端部分</li>
<li>公用优化器：将生成的中间文件进行优化, 去除冗余代码, 进行结构优化。</li>
<li>后端：将优化后的中间代码再次转换, 变为汇编语言, 再次进行优化. 最后将各个文件代码转换为二进制代码(机器语言)并链接以生成一个可执行文件。</li>
</ol>
<h5 id="LLVM-架构的优点"><a href="#LLVM-架构的优点" class="headerlink" title="LLVM 架构的优点"></a>LLVM 架构的优点</h5><ol>
<li>不同的前端后端使用统一的中间代码LLVM Intermediate Representation (LLVM IR)</li>
<li>如果需要支持一种新的编程语言, 那么只需要实现一个新的前端(Swift 就是新增了一个针对于 Swift 的前端)</li>
<li>如果需要支持一种新的硬件设备, 那么只需要实现一个新的后端</li>
<li>优化阶段是一个通用的阶段, 它针对的是统一的LLVM IR, 不论是支持新的编程语言, 还是支持新的硬件设备, 都不需要对优化阶段做修改</li>
<li>LLVM现在被作为实现各种静态和运行时编译语言的通用基础结构(GCC家族, Java, .NET, Python, Ruby, Scheme, Haskell, D等)</li>
</ol>
<p><img src="/Assembly02.png" alt="image"></p>
<h4 id="Part03-汇编语言种类及选择："><a href="#Part03-汇编语言种类及选择：" class="headerlink" title="Part03 - 汇编语言种类及选择："></a>Part03 - 汇编语言种类及选择：</h4><h5 id="汇编语言种类"><a href="#汇编语言种类" class="headerlink" title="汇编语言种类"></a>汇编语言种类</h5><ol>
<li><code> AT&amp;T</code>格式(<code>UNIX</code>, <code>MAC</code>阵营):<code>8086</code>汇编(16bit 架构)<code>x64</code>汇编(64bit 架构)</li>
<li><code>Intel</code>格式(WIN阵营): <code>x86</code>汇编(32bit 架构)</li>
<li><code>ARM</code> 格式 (移动设备阵营): 只用在 <code>arm </code>处理器上</li>
</ol>
<h5 id="汇编语言选择"><a href="#汇编语言选择" class="headerlink" title="汇编语言选择"></a>汇编语言选择</h5><p>虽然不同的架构对应着不同的汇编语言，但是原理基本上是一样的，为了调试方便，我们将以X86-64架构来探究Swift中函数调用的本质。</p>
<h4 id="Part04-AT-amp-T汇编"><a href="#Part04-AT-amp-T汇编" class="headerlink" title="Part04 - AT&amp;T汇编"></a>Part04 - AT&amp;T汇编</h4><h5 id="寄存器和数据类型"><a href="#寄存器和数据类型" class="headerlink" title="寄存器和数据类型"></a>寄存器和数据类型</h5><p>X86-64有16个通用(几乎都是通用的)64位整数寄存器：</p>
<table>
<thead>
<tr>
<th>%rax</th>
<th>%rbx</th>
<th>%rcx</th>
<th>%rdx</th>
<th>%rsi</th>
<th>%rdi</th>
<th>%rbp</th>
<th>%rsp</th>
<th>%r8</th>
<th>%r9</th>
<th>%r10</th>
<th>%r11</th>
<th>%r12</th>
<th>%r13</th>
<th>%r14</th>
<th>%r15</th>
</tr>
</thead>
</table>
<p>因为早期处理器的不同寄存器的用途不同，并不是所有的指令都可以应用于每个寄存器。（现在基本上都是通用寄存器了）随着设计的发展，增加了新的指令和寻址模式，使各种寄存器几乎相等。除了几条特殊的指令，比如与字符串处理有关的指令，需要使用％rsi和％rdi，另外，还有两个寄存器保留用作堆栈指针（％rsp）和基址指针（％rbp）。最后的八个被编号的寄存器没有特别的限制。除此之外还有一个特殊的寄存器%rip(instruction pointer)，一般情况下你不需要关注这个寄存器,但是这个寄存器很重要，你需要知道他的功能，后面在说函数调用时会提及。</p>
<p>多年来X86架构已经从8位扩展到了32位，因此每个寄存器都有一些内部结构如下图：<br><img src="/Assembly03.png" alt="image"></p>
<h5 id="寻址模式"><a href="#寻址模式" class="headerlink" title="寻址模式"></a>寻址模式</h5><p>什么是寻址模式？就是数据在内存寄和寄存器之间进行移动时，取得数据地址的不同表达方式。最常用的寻址的汇编指令是mov。x86-64使用的是复杂指令集(cisc)，因此mov有许多不同的变体，可以在不同单元之间移动不同类型的据。mov与大多数指令一样，具有单字母后缀，用于确定要移动的数据量。下表用于描述各种大小的数据值：</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>全称</th>
<th>Size</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>byte</td>
<td>1byte(8 bits)</td>
</tr>
<tr>
<td>W</td>
<td>word</td>
<td>2byte(16 bits)</td>
</tr>
<tr>
<td>L</td>
<td>long</td>
<td>4byte(32 bits)</td>
</tr>
<tr>
<td>Q</td>
<td>quadword</td>
<td>8byte(64 bits)</td>
</tr>
</tbody></table>
<p><code>MOVB</code>移动一个字节，<code>MOVW</code>移动一个字，<code>MOVL</code>移动一个长整形，<code>MOVQ</code>移动一个四字。一般来说，<code>MOV</code>指令移动数据的大小必须与后缀匹配。虽然可以忽略后缀，汇编器将尝试根据参数选择合适的<code>MOV</code>指令。但是，不推荐这样做，因为它可能会造成预料之外的结果。</p>
<p>对于<code>AT&amp;T</code>语法使用<code>MOV</code>寻址时需要两个参数，第一个参数是<code>源地址</code>，第二个参数是<code>目标地址</code>。<code>原地址</code>的表达方式不一样那么寻址的方式也就不一样。比如，访问全局变量使用一个简单变量的名称比如<code>x</code>，我们称之为全局符号寻址。<code>printf</code>一个整数常量，由美元符号+数值表示(例如<code>$ 56</code>)，我们称之为直接寻址。访问寄存器的值直接使用寄存器的名字如  <code>%rbx</code>，我们称之为寄存器寻址。如果寄存器中存放的是一个地址，访问这个地址中的数据时需要在寄存器外面加上括号如<code>(%rbx)</code>，我们称之为间接寻址。如果寄存器中存放的是一个数组的地址，我们需要访问数组中的元素时可能需要操作这个地址进行偏移，如<code>8(％rcx）</code>是指<code>％rcx</code>中存放的的地址加<code>8</code>字节存储单元的值，我们称之为相对基址寻址（此模式对于操作堆栈，局部变量和函数参数非常重要）。在相对基址寻址上有各种复杂的变化，例如<code>-16（％rbx，％rcx，8</code>）是指地址<code>-16 +％rbx +％rcx * 8</code>处的值。此模式对于访问排列在数组中的特殊大小的元素非常有用。</p>
<p>以下是使用各种寻址模式将64位值加载到％rax的示例：</p>
<table>
<thead>
<tr>
<th>寻址模式</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>全局符号寻址(Global Symbol)</td>
<td>MOVQ x, %rax</td>
</tr>
<tr>
<td>直接寻址(Immediate)</td>
<td>MOVQ $56, %rax</td>
</tr>
<tr>
<td>寄存器寻址(Register)</td>
<td>MOVQ %rbx, %rax</td>
</tr>
<tr>
<td>间接寻址(Indirect)</td>
<td>MOVQ (%rsp), %rax</td>
</tr>
<tr>
<td>相对基址寻址(Base-Relative)</td>
<td>MOVQ -8(%rbp), %rax</td>
</tr>
<tr>
<td>相对基址偏移缩放寻址(Offset-Scaled-Base-Relative)</td>
<td>MOVQ -16(%rbx,%rcx,8), %rax</td>
</tr>
</tbody></table>
<p>通常，可以使用相同的寻址模式将数据存储到寄存器和内存。但是，并不是所有模式都支持。比如不能对<code>MOV</code>的两个参数都使用<code>base-relative mode</code>。像<code>MOVQ -8（％rbx</code>），<code>-8（％rbx</code>）这样是不行的。要准确查看支持哪些寻址模式组合，您必须阅读相关指令的手册。</p>
<h5 id="基础运算指令"><a href="#基础运算指令" class="headerlink" title="基础运算指令"></a>基础运算指令</h5><p>编译器需要四个基本的算术指令： <code>ADD</code>, <code>SUB</code>, <code>IMUL</code>, 和<code>IDIV</code>(加减乘除)。<code>add</code>和<code>sub</code>有两个操作数：一个来源值和一个被操作数。例如，这条指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addq %rbx, %rax</span><br></pre></td></tr></table></figure>

<p>将<code>％rbx</code>添加到<code>％rax</code>，并将结果放在<code>％rax</code>中，覆盖之前可能存在的内容。这就要求你在使用寄存器时要小心。 例如，假设你想计算 <code>c = b *（b + a）</code>，其中a和b是全局整数。要做到这一点，你必须小心，在执行加法时不要覆盖b的值。这里有一个实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movq  a, %rax</span><br><span class="line">movq  b, %rbx</span><br><span class="line">addq  %rbx, %rax</span><br><span class="line">imulq %rbx</span><br><span class="line">movq  %rax, c</span><br></pre></td></tr></table></figure>
<p><code>imul</code>指令有点不太一样：它将其参数乘以<code>％rax</code>的内容，然后将结果的低64位放入<code>％rax</code>，将高64位放入<code>％rdx</code>。（将两个64位数字相乘会产生一个128位数字。）</p>
<p><code>idiv</code>指令和乘法指令差不多：它以一个128位整数值开始，其低64位位于<code>％rax</code>，高位64位位于<code>％rdx</code>中，并将其除以参数。<code>（CDQO</code>指令用于将<code>％rax</code>符号扩展为<code>％rdx</code>，以便正确处理负值。）商被放在<code>％rax</code>中，余数放在<code>％rdx</code>中。例如，除以5：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq a,  %rax    # set the low 64 bits of the dividend</span><br><span class="line">cdqo             # sign-extend %rax into %rdx</span><br><span class="line">idivq $5 </span><br></pre></td></tr></table></figure>

<p>大多数语言中的求模指令只是利用<code>％rdx</code>中剩余的余数,指令<code>INC</code>和<code>DEC</code>分别递增和递减寄存器。例如，语句<code>a = ++ b</code>可以翻译为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movq b, %rax</span><br><span class="line">incq %rax</span><br><span class="line">movq %rax, a</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>布尔操作的工作方式非常类似：AND，OR，和XOR指令需要两个参数，而NOT指令只需要一个参数。像MOV指令一样，各种算术指令可以在各种寻址模式下工作。但是，您可能会发现使用MOV将值载入和载出寄存器是最方便的，然后仅使用寄存器来执行算术运算。</p>
<h5 id="比较和跳转指令"><a href="#比较和跳转指令" class="headerlink" title="比较和跳转指令"></a>比较和跳转指令</h5><p>使用<code>JMP</code>指令，我们可以创建一个简单的无限循环，使用<code>％eax</code>寄存器从零开始计数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   movq $0, %rax</span><br><span class="line">loop:</span><br><span class="line">    incq %rax</span><br><span class="line">    jmp loop</span><br></pre></td></tr></table></figure>

<p>为了定义更有用的程序结构，如终止循环和<code>if-then</code>等语句，我们必须有一个可以改变程序流程的机制。在大多数汇编语言中，这些处理由两种不同的指令处理：比较和跳转。<br>所有的比较都是通过<code>CMP</code>指令完成的。<code>CMP</code>比较两个不同的寄存器，然后在内部<code>EFLAGS</code>寄存器中设置几个位，记录这些值是相同，更大还是更小。你不需要直接看<code>EFLAGS</code>寄存器的值。而是根据结果的不同来做适当的跳转：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>je</td>
<td>如果大于则跳转</td>
</tr>
<tr>
<td>jne</td>
<td>如果不等于则跳转</td>
</tr>
<tr>
<td>jl</td>
<td>如果小于则跳转</td>
</tr>
<tr>
<td>jle</td>
<td>如果小于等于则跳转</td>
</tr>
<tr>
<td>jg</td>
<td>如果大于则跳转</td>
</tr>
<tr>
<td>jge</td>
<td>如果大于等于则跳转</td>
</tr>
</tbody></table>
<p>举个例子，这里是一个循环来使<code>％rax</code>从0到5：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        movq $0, %rax</span><br><span class="line">loop:</span><br><span class="line">        incq %rax</span><br><span class="line">        cmpq $5, %rax</span><br><span class="line">        jle  loop</span><br></pre></td></tr></table></figure>

<p>再举个例子，一个条件赋值：如果全局变量x&gt;&#x3D;0，那么全局变量y&#x3D;10，否则 y&#x3D;20：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        movq x, %rax</span><br><span class="line">        cmpq $0, %rax</span><br><span class="line">        jle  twenty</span><br><span class="line">ten:</span><br><span class="line">        movq $10, %rbx</span><br><span class="line">        jmp  done</span><br><span class="line">twenty:</span><br><span class="line">        movq $20, %rbx</span><br><span class="line">        jmp  done</span><br><span class="line">done:</span><br><span class="line">        movq %ebx, y</span><br></pre></td></tr></table></figure>

<p>跳转的参数是目标标签。这些标签在一个汇编文件中必须是唯一且私密的，除了包含在.globl内的标签 ，其他标签不能在文件外部看到，也就是不能在文件外调用。用c语言来说，一个普通的汇编标签是static的，而.globl标签是extern</p>
<h6 id="其他常用寄存器指令"><a href="#其他常用寄存器指令" class="headerlink" title="其他常用寄存器指令"></a>其他常用寄存器指令</h6><ul>
<li><code>leaq %rbp,%rax</code>: 内存赋值 <code>lea</code>, 将 <code>rbq</code> 的内存地址值赋给 <code>rax</code></li>
<li><code>xorl %eax, %eax</code>: 异或<code> xor</code>, 将 <code>eax </code>清 <code>0</code>, 自己异或自己</li>
<li><code>jmp 0x80001</code>: 跳转 <code>jmp</code>, 跳转到函数地址为 <code>0x80001</code> 的地址</li>
<li><code>jmp *(%rax)</code>: 间接跳转<code> *()</code>, <code>rax</code> 是个内存地址,<code>*(rax)</code>是拿到<code> rax</code> 地址里的值</li>
<li><code>callq 0x80001</code>: 函数调用<code> call</code>, 调用地址为<code> 0x80001</code> 的函数, 一般配合 <code>retq</code></li>
</ul>
<h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>栈是一种辅助数据结构，主要用于记录程序的函数调用历史记录以及不适合寄存器的局部变量。栈从高地址向低地址增长。<code>％rsp</code>寄存器被称为<code>“栈指针”</code>并跟踪堆栈中最底层(也就是最新的)的数据。因此，要将<code>％rax</code>压入堆栈，我们必须从<code>％rsp</code>中减去<code>8（％rax</code>的大小，以字节为单位），然后写入<code>％rsp</code>指向的位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subq $8, %rsp</span><br><span class="line">movq %rax, (%rsp)</span><br></pre></td></tr></table></figure>

<p>从栈中弹出一个值与上面的操作相反：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movq (%rsp), %rax</span><br><span class="line">addq $8, %rsp</span><br></pre></td></tr></table></figure>

<p>从栈中丢弃最新的值，只需移动堆栈指针即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addq $8, %rsp</span><br></pre></td></tr></table></figure>

<p>当然，压栈(入栈)或出栈是经常使用到的操作，所以都有简化的单条指令，其行为与上面的完全一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pushq %rax</span><br><span class="line">popq  %rax</span><br></pre></td></tr></table></figure>


<h5 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h5><p>所有c标准库中可用的函数也可以在汇编语言程序中使用。以一种称为“调用约定”的标准方式调用，以便用多种语言编写的代码都可以链接在一起。<br>在x86 32位机器中。调用约定只是将每个参数入栈，然后调用该函数。被调用函数在栈中查找参数，完成它的工作之后，将结果存储到单个寄存器中。然后调用者弹出栈中的参数。<br>Linux上x86-64使用的调用约定有所不同，称之为System V ABI。完整的约定相当复杂，但以下是对我们来说足够简单的解释：</p>
<ul>
<li>整数参数（包括指针）按顺序放在寄存器％rdi，％rsi，％rdx，％rcx，％r8和％r9中。</li>
<li>浮点参数按顺序放置在寄存器％xmm0-％xmm7中。</li>
<li>超过可用寄存器的参数被压入栈。</li>
<li>如果函数使用可变数量的参数（如printf），那么必须将％eax寄存器设置为浮点参数的数量。</li>
<li>被调用的函数可以使用任何寄存器，但如果它们发生了变化，则必须恢复寄存器％rbx，％rbp，％rsp和％r12-％r15的值。</li>
<li>函数的返回值存储在％eax中。</li>
</ul>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>用途</th>
<th>是否需要保存</th>
</tr>
</thead>
<tbody><tr>
<td>%rax</td>
<td>保存返回结果</td>
<td>无需保存</td>
</tr>
<tr>
<td>%rbx</td>
<td>-</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%rcx</td>
<td>参数4</td>
<td>无需保存</td>
</tr>
<tr>
<td>%rdx</td>
<td>参数3</td>
<td>无需保存</td>
</tr>
<tr>
<td>%rsi</td>
<td>参数2</td>
<td>无需保存</td>
</tr>
<tr>
<td>%rdi</td>
<td>参数1</td>
<td>无需保存</td>
</tr>
<tr>
<td>%rbp</td>
<td>栈基址指针</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%rsp</td>
<td>栈指针</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r8</td>
<td>参数5</td>
<td>无需保存</td>
</tr>
<tr>
<td>%r9</td>
<td>参数6</td>
<td>无需保存</td>
</tr>
<tr>
<td>%r10</td>
<td>-</td>
<td>调用者保存</td>
</tr>
<tr>
<td>%r11</td>
<td>-</td>
<td>调用者保存</td>
</tr>
<tr>
<td>%r12</td>
<td>-</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r13</td>
<td>-</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r14</td>
<td>-</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r15</td>
<td>-</td>
<td>被调用者保存</td>
</tr>
</tbody></table>
<p>每个函数都需要使用一系列寄存器来执行计算。然而，当一个函数被另一个函数调用时会发生什么？我们不希望调用者当前使用的任何寄存器被调用的函数破坏。为了防止这种情况发生，每个函数必须保存并恢复它使用的所有寄存器，方法是先将它们入栈，然后在返回之前将它们从堆栈弹出。在函数调用的过程中，栈基址指针<code>%rbp</code>始终指向当前函数调用开始时栈的位置，栈指针<code>%rsp</code>始终指向栈中最新的元素对应的位置。<code>%rbp</code>和<code>%rsp</code>之间的元素被我们成为<code>&quot;栈帧&quot;</code>，也叫<code>&quot;活动记录&quot;</code>。函数的调用过程其实就是栈帧被创建，扩张然后被销毁的过程。在说明函数调用流程前，我们不得不提到<code> %rip(instruction pointer)</code> 指令指针寄存器。<code>%rip</code>中存放的是CPU需要执行的下一条指令的地址。每当执行完一条指令之后，这个寄存器会自动增加(可以这样理解)以便指向新的指令的地址。有了这些基础，接下来我们以一段完整的程序代码来解释函数的调用流程，有下面一段c代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int sum(int a, int b)&#123;</span><br><span class="line">    return (a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int x = sum(1, 2);</span><br><span class="line">    printf(&quot;result is:%d\n&quot;, x);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译为汇编代码之后，为了方便读代码，我们去除一些不需要的指示段之后得到如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">.file   &quot;main.c&quot;</span><br><span class="line">    .text</span><br><span class="line">    .globl  sum</span><br><span class="line">    .type   sum, @function</span><br><span class="line">sum:</span><br><span class="line">.LFB0:</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    movl    %edi, -4(%rbp)</span><br><span class="line">    movl    %esi, -8(%rbp)</span><br><span class="line">    movl    -4(%rbp), %edx</span><br><span class="line">    movl    -8(%rbp), %eax</span><br><span class="line">    addl    %edx, %eax</span><br><span class="line">    popq    %rbp</span><br><span class="line">    ret</span><br><span class="line">.LFE0:</span><br><span class="line">    .size   sum, .-sum</span><br><span class="line">    .section    .rodata</span><br><span class="line">.LC0:</span><br><span class="line">    .string &quot;result is:%d\n&quot;</span><br><span class="line">    .text</span><br><span class="line">    .globl  main</span><br><span class="line">    .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB1:</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    subq    $16, %rsp</span><br><span class="line">    movl    $2, %esi</span><br><span class="line">    movl    $1, %edi</span><br><span class="line">    call    sum</span><br><span class="line">    movl    %eax, -4(%rbp)</span><br><span class="line">    movl    -4(%rbp), %eax</span><br><span class="line">    movl    %eax, %esi</span><br><span class="line">    movl    $.LC0, %edi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    leave</span><br><span class="line">    ret</span><br><span class="line">.LFE1:</span><br><span class="line">    .size   main, .-main</span><br><span class="line">    .ident  &quot;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609&quot;</span><br><span class="line">    .section    .note.GNU-stack,&quot;&quot;,@progbits</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们知道linux系统中<code>main</code>函数是由glibc中的 <code>exec()</code>簇 函数调用的，比如我们从shell环境中启动程序最终就是由 <code>execvp()</code>调用而来。我们这里不展开说明，你只需要知道<code>main</code>函数其实也是被调用的函数。我们从<code>main</code>函数的第一条指令开始：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB1:</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br></pre></td></tr></table></figure>
<p>首先，将当前的栈基址指针%rbp入栈，函数调用结束后我们就可以从栈中取得函数调用前%rbp指向的位置，进而恢复栈到之前的样子。然后使当前栈指针指向新的位置。然后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subq    $16, %rsp</span><br><span class="line">movl    $2, %esi</span><br><span class="line">movl    $1, %edi</span><br></pre></td></tr></table></figure>

<p>在栈上申请16字节的空间以便存放后面的临时变量x，然后根据System V ABI的调用约定将传递给sum函数的参数放入%esi和%edi中(因为是int类型占用4个字节，所以只需要用寄存器的低4字节即可)。这里你可能会发现编译器没有将需要调用者保存的%r10和%r11入栈，因为编译器知道在main函数中不会使用到%r10和%r11寄存器所以无需保存。然后发出调用指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call sum</span><br></pre></td></tr></table></figure>
<p>需要注意以上的CALL指令等同于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pushq %rip</span><br><span class="line">jmp sum</span><br></pre></td></tr></table></figure>
<p>我们把<code>%rip</code>当前的内容放入栈中，以便函数<code>sum</code>调用结束我们可以知道接下来该执行哪条指令，我们假设栈从<code>0xC0000000</code>处开始向低处延伸。到这个阶段栈的变化过程如下所示：</p>
<p><img src="/Assembly04.png" alt="image"></p>
<p>现在程序跳转到sum处执行计算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pushq   %rbp</span><br><span class="line">movq    %rsp, %rbp</span><br><span class="line">movl    %edi, -4(%rbp)</span><br><span class="line">movl    %esi, -8(%rbp)</span><br><span class="line">movl    -4(%rbp), %edx</span><br><span class="line">movl    -8(%rbp), %eax</span><br><span class="line">addl    %edx, %eax</span><br></pre></td></tr></table></figure>

<p>和<code>main</code>函数被调用一样，<code>sum</code>函数被调用时，首先也是保存<code>%rbp</code>，然后更新栈指针<code>%rsp</code>，将两个参数拷贝到栈中进行使用。在这里你可能看到了和<code>main</code> 函数不一样的地方，局部变量保存在栈中并没有像main函数中那样引起<code>%rsp</code>的移动(对比<code>main</code>函数中的<code>SUBQ 16</code>)。是因为编译器知道sum中不会再调用其它函数，也就不用保存数据到栈中了，直接使用栈空间即可。所以就无需位移<code>%rsp</code>。计算完成后结果保存在<code>%eax</code>中，现在我们更新一下栈的变化：</p>
<p><img src="/Assembly05.png" alt="image"></p>
<p>然后返回到main函数时执行了如下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">popq    %rbp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>先恢复调用前的栈基址指针%rbp，然后此时栈顶的元素就是函数调用之后需要执行的下一条指令的地址，RET指令等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">popq    %rip</span><br></pre></td></tr></table></figure>

<p>这样就可以跳转到函数结束后的下一条指令 “movl %eax, -4(%rbp)”处继续执行,至此我们看一下完整调用过程中栈的变化：</p>
<p><img src="/Assembly06.png" alt="image"></p>
<p>更多关于寄存器的知识可以看<a target="_blank" rel="noopener" href="https://nifengz.com/introduction_x64_assembly/">这篇博客</a>,讲的更加详细</p>
<h4 id="Part05-LLDB常用指令"><a href="#Part05-LLDB常用指令" class="headerlink" title="Part05 - LLDB常用指令"></a>Part05 - LLDB常用指令</h4><p>了解了汇编的基本指令时候，我们需要再了解在Xcode中如何使用LLDB指令来调试汇编代码</p>
<ul>
<li>读取寄存器的值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">register read/ </span><br><span class="line">/*例*/POPQ  %rax</span><br><span class="line">register read/x rax    // 读取寄存器 rax 里面的值，/后面的参数为进制：x:16 进制,f: 浮点,d:10 进制</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>修改寄存器的值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">register write</span><br><span class="line">/*例*/</span><br><span class="line">register write rax 4 // 将rax修改为 4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>读取内存中的值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x/数量-格式-字节大小</span><br><span class="line"></span><br><span class="line">/*例*/</span><br><span class="line"></span><br><span class="line">x/4xg 0x1000002</span><br><span class="line">// 将 0x1000002 地址的值, 以 8 个字节的格式, 分成 4 份, 16 进制 展示</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>修改内存中的值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">memory write 内存地址 数值</span><br><span class="line"></span><br><span class="line">/*例*/</span><br><span class="line"></span><br><span class="line">memory write  0x1000002 10</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>格式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x 是十六进制，f是浮点，d是十进制，</span><br></pre></td></tr></table></figure>

<ul>
<li>字节大小</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b - byte 1 字节</span><br><span class="line">h - half word 2 字节</span><br><span class="line">w - word 4 字节</span><br><span class="line">g - giant word 8 字节</span><br></pre></td></tr></table></figure>

<ul>
<li>单步运行，把子函数当作一个整体，一步执行（源码级别）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread step-over、next、n</span><br></pre></td></tr></table></figure>
<ul>
<li>单步运行，遇到子函数会进入子函数(源码级别)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread step-in 、 step、s</span><br></pre></td></tr></table></figure>
<ul>
<li>单步运行，把子函数当作一个整体一步执行（汇编级别）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread step-inst-over 、 nexti、ni</span><br></pre></td></tr></table></figure>

<ul>
<li>单步运行，遇到子函数会进入子函数（汇编级别）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread step-inst 、 stepi、si</span><br></pre></td></tr></table></figure>
<ul>
<li>直接执行完当前函数的所有代码，返回上一个函数（遇到断点会卡住）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread step-out 、finish</span><br></pre></td></tr></table></figure>

<h4 id="Part06-Swift汇编例子"><a href="#Part06-Swift汇编例子" class="headerlink" title="Part06 - Swift汇编例子"></a>Part06 - Swift汇编例子</h4><ol>
<li>新建一个<code>Command Line Tool</code>工程，并在<code>main.swift</code>文件中新建一个<code>sum</code>函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func sum( a: Int, b: Int) -&gt; Int&#123;</span><br><span class="line">    return (a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>Xcode</code>进入汇编调试模式，并在<code>main</code>函数中调用<code>sum</code>函数</li>
</ol>
<p><img src="/Assembly07.png" alt="image"></p>
<p>3.在<code>main</code>函数中，调用<code>sum</code>函数，在调用<code>sum</code>函数地方打断点</p>
<p><img src="/Assembly08.png" alt="image"></p>
<p>4.通过在控制台执行 <code>n</code>指令，可以定位到第11行,执行<code>si</code>指令可以进入<code>sum</code>函数，在<code>sum</code>函数中，我们可以看到最终通过<code>%rdx</code>和<code>%rcx</code>完成累加，并最终将值放如<code>%rax</code>寄存器，作为函数返回值<br><img src="/Assembly09.png" alt="image"></p>
<h4 id="Part07-参考"><a href="#Part07-参考" class="headerlink" title="Part07 - 参考"></a>Part07 - 参考</h4><p><a target="_blank" rel="noopener" href="https://nifengz.com/introduction_x64_assembly/">x86-64汇编入门
</a></p>
<p><a target="_blank" rel="noopener" href="https://hanleylee.com/compile-of-ios-project.html">iOS 之编译</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27339191">x86-64 下函数调用及栈帧原理</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5ddf66385188256e855b6e0c">从 简单汇编基础 到 Swift 不简单的 a + 1</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://iamlay.com/2020/04/02/week14/" data-id="clfj8cp2r001wfbf3eun2b7xu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-week13" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/29/week13/" class="article-date">
  <time datetime="2020-03-29T10:44:06.000Z" itemprop="datePublished">2020-03-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%91%A8%E6%8A%A5/">周报</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/29/week13/">以技术之名周报01#开篇| 2020-03-29</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="为什么要写博客？"><a href="#为什么要写博客？" class="headerlink" title="为什么要写博客？"></a>为什么要写博客？</h5><p>写博客是一个输出和分享的过程，将会对博主本人和读者产生积极的影响。为了保证输出对读者存在价值，首先需要确保博客内容的准确性，即不要输出错误的内容误导读者；要保证博客内容的逻辑性，即会使让读者读起来有云里雾里的感觉。为了达到这样的效果，就要求博主对分享的知识有足够深刻的理解，并能够转化为自己的语言分享出来。高质量的博客，对博主和读者而言，是一种双赢的结果。</p>
<h5 id="为什么没有养成持续以恒的习惯？"><a href="#为什么没有养成持续以恒的习惯？" class="headerlink" title="为什么没有养成持续以恒的习惯？"></a>为什么没有养成持续以恒的习惯？</h5><p>工作四年半的时间，写博客一直以来都处于养鱼的状态，没有养成持之以恒的习惯，非常惭愧。除了开始工作的那段时间有比较高的热情，接下来的几年基本放弃，总结下来，大概有下面几点原因：</p>
<ul>
<li><input checked disabled type="checkbox"> 刚开始工作，出生牛犊不怕虎，不怕嘲笑。工作一段时间，深感技术不足，以后畏首畏尾。</li>
<li><input checked disabled type="checkbox"> 博客搭建成本有点高，更换电脑之后，需要重新搭建，怕麻烦，一直拖着没做</li>
<li><input checked disabled type="checkbox"> 在不同的公司，工作强度和方向不一样，在比较忙、没有值得分享的技术点的情况下没有分享的精力和动力</li>
<li><input checked disabled type="checkbox"> 学习的热情没有持续，没有输入很难保持产出</li>
<li><input checked disabled type="checkbox"> 深入思考的时候太少，面向谷歌和百度开发一度程度扼杀人思考的能力</li>
</ul>
<h5 id="如何改进？"><a href="#如何改进？" class="headerlink" title="如何改进？"></a>如何改进？</h5><ul>
<li><input checked disabled type="checkbox"> 搭建好新的博客，做好博客的版本管理，搭建好博客不要随便改动博客配置，须知博客的本质重在内容而不是花里胡哨的样式，切勿本末倒置</li>
<li><input checked disabled type="checkbox"> 强制自己写博客，以至少每周一篇周报的频率写技术分享，倒逼自己在工作中寻找值得分享的知识点</li>
<li><input checked disabled type="checkbox"> 保持持续学习的习惯，不断更新自己的知识栈</li>
<li><input checked disabled type="checkbox"> 减少面向百度、谷歌开发，多思考，深入思考，探索本质</li>
</ul>
<h5 id="写在开篇-题外话"><a href="#写在开篇-题外话" class="headerlink" title="写在开篇-题外话"></a>写在开篇-题外话</h5><p>2020年是不同寻常的一年，战争、蝗灾、粮食危机、新型冠状肺炎…天灾人祸似乎要在这一年集中爆发，极大的考验各个国家面危机的能力。全世界现在一片混乱，人道主义危机轮番上演，西方世界逐渐撕掉文明的面具，暴露出强盗的本性。而在过去的两个多月，全国人民在党的带领下众志成城，付出了极大代价，艰难战胜了新冠肺炎，逐渐复工复产。然而面对动荡的世界，中国无法独善其身，不断向其他国家援助医疗物资、派遣医疗专家，开启支援全世界的模式。在中国逐渐展现出世界领袖气质的同时，大洋彼岸的现任世界领袖在特朗普的带领下，开启了一连串迷之操作，迅速将美国带入新冠肺炎的震中。为了挽救股票市场，美国将基准利率降到0，并开启无限QE，疯狂印钞2万亿美元大放水。这次疫情也许会加速新一轮的经济危机的到来，到时候将会出现大量公司倒闭，无数工薪族面临裁员。我们要做的是：做最坏的打算，抱最大的希望，不断的提升自己技术能力，确保自己在经济大萧条的时候保持足够的竞争力，将危机对自己的影响降到最低。希望各位共勉！</p>
<h5 id="说点开心的"><a href="#说点开心的" class="headerlink" title="说点开心的"></a>说点开心的</h5><p>从1.29号到北京，到现在整整两个月，除了家和公司两个地方，其他地方都没有去过，像我这样的自认为很能宅的人都快憋坏了。因为之前答应帮同学买药，就趁着这大好春光去了趟北京协和医院，正好放放风、撒撒野。虽然因为上班时间原因药没有买成，但是发现协和医院附近四合院景色不错，和大家分享一下，就放在文章最后了。</p>
<h5 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h5><p>第一周周报，就是想和大家分享下自己的想法，也没有准备技术文章。和大家分享一些北京的春光，希望大家：面朝大海，春暖花开。</p>
<img src="/2020/03/29/week13/week_13_01.jpeg" width="80%" height="30%" align="center/">

<img src="/2020/03/29/week13/week_13_02.jpeg" width="80%" height="30%" align="center/">

<img src="/2020/03/29/week13/week_13_03.jpeg" width="80%" height="30%" align="center/">

<img src="/2020/03/29/week13/week_13_04.jpeg" width="80%" height="30%" align="center/">

<img src="/2020/03/29/week13/week_13_05.jpeg" width="80%" height="30%" align="center/">

<img src="/2020/03/29/week13/week_13_06.jpeg" width="80%" height="30%" align="center/">

<img src="/2020/03/29/week13/week_13_07.jpeg" width="80%" height="30%" align="center/">



      
    </div>
    <footer class="article-footer">
      <a data-url="http://iamlay.com/2020/03/29/week13/" data-id="clfj8cp2q001tfbf3cw982lk5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HexoNextReadmore" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/27/HexoNextReadmore/" class="article-date">
  <time datetime="2020-03-27T04:21:09.000Z" itemprop="datePublished">2020-03-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BD%91%E7%AB%99/">网站</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/27/HexoNextReadmore/">Next主题-关于添加文章摘要的一点思考</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="什么是摘要？"><a href="#什么是摘要？" class="headerlink" title="什么是摘要？"></a>什么是摘要？</h4><blockquote>
<p> 摘要是简洁、具体的摘要要反映论文的实质性内容，展示论文内容足够的信息，体现论文的创新性，展现论文的重要梗概，一般由具体研究的对象、方法、结果、结论四要素组成。</p>
</blockquote>
<h4 id="为什么要添加文章摘要？"><a href="#为什么要添加文章摘要？" class="headerlink" title="为什么要添加文章摘要？"></a>为什么要添加文章摘要？</h4><ol>
<li>我们写的每一篇技术博客，都应该有文章摘要，用简短的文字来交代该篇博客的写作背景、遇到的问题、是否解决、采取的方法。通过阅读文章摘要，读者就应该大致能够判断该篇文章对自己是否存在价值，避免把宝贵的时间浪费在没有意义的文章上。</li>
<li>Hexo写作的文章默认的编辑模式是全文模式，如果采用全文模式来写文章，在浏览整个网站的过程中将会把非常多的时间浪费在滑动屏幕这种没有价值的事情上。对读者而言，这是一个相当不友好的体验，而且会分散读者的注意力。</li>
<li>美观度</li>
</ol>
<hr>
<p><strong>很多关于文章摘要的博客，基本上都是在教给大家如何去截断文章，严格讲这并不是文章摘要，只是为了美观度截取了部分文章。还是建议大家在写完博客之后，可以认真写一下文章的摘要，形成一个好的写作习惯。</strong></p>
<hr>
<h4 id="Hexo添加文摘要的三种方式"><a href="#Hexo添加文摘要的三种方式" class="headerlink" title="Hexo添加文摘要的三种方式"></a>Hexo添加文摘要的三种方式</h4><ol>
<li>在文章中使用<code>&lt;!--more--&gt;</code>进行手动截断,这其实就是上面讲到的文章截断，推荐在使用<code>&lt;!--more--&gt;</code>之前写好文章摘要</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">本文的主要目的是关于写文章摘要的一些思考，以及Hexo的Next主题添加文章摘要的三种方式，希望能给读者提供一些帮助。</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line"> 摘要是简洁、具体的摘要要反映论文的实质性内容，展示论文内容足够的信息，体现论文的创新性，展现论文的重要梗概，一般由具体研究的对象、方法、结果、结论四要素组成。</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ol start="2">
<li>在文章中的<code>front-matter</code>中添加<code>description</code>，并提供文章摘要。<br>这种方式只会在首页列表中显示文章的摘要内容，进入文章详情后不会再显示。使用这种方法也可以实现首页文章部分显示的效果。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Next主题生成文章摘要的三种方式</span><br><span class="line">date: 2020-03-27 12:21:09</span><br><span class="line">tags:</span><br><span class="line">- 原创</span><br><span class="line">categories: </span><br><span class="line">- 网站</span><br><span class="line">description: 本文的主要目的是关于写文章摘要的一些思考，以及Hexo的Next主题添加文章摘要的三种方式，希望能给读者提供一些帮助。</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>自动生成摘要，主题配置文件中添加以下代码，这种方是更加机械的切割，没有办法控制摘要显示的内容, 而且是对整个网站生效的,不是特别推荐</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://iamlay.com/2020/03/27/HexoNextReadmore/" data-id="clfj8cp2a000cfbf3hgjihef2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HexoNextTheme" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/24/HexoNextTheme/" class="article-date">
  <time datetime="2020-03-24T05:32:13.000Z" itemprop="datePublished">2020-03-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BD%91%E7%AB%99/">网站</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/24/HexoNextTheme/">Next主题 - 图片设置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h3><h4 id="Hexo有网络图片和插入本地图片两种方式："><a href="#Hexo有网络图片和插入本地图片两种方式：" class="headerlink" title="Hexo有网络图片和插入本地图片两种方式："></a>Hexo有<code>网络图片</code>和<code>插入本地图片</code>两种方式：</h4><ul>
<li>插入网络图片可以用常用的Markdown的方式进行插入: <code>![img-title](img-url) </code></li>
<li>插入本地图片，主要涉及到本地图片资源的管理，相对插入网络图片复杂一些，但是引用方式大同小异，针对插入本地图片我们稍做展开</li>
</ul>
        
          <p class="article-more-link">
            <a href="/2020/03/24/HexoNextTheme/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://iamlay.com/2020/03/24/HexoNextTheme/" data-id="clfj8cp2d000kfbf3g69k6f1h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-InstallTomcat" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/21/InstallTomcat/" class="article-date">
  <time datetime="2020-03-21T08:47:08.000Z" itemprop="datePublished">2020-03-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/21/InstallTomcat/">Linux(Centos)安装tomcat并且部署Java Web项目---踩坑</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="购买云服务器"><a href="#购买云服务器" class="headerlink" title="购买云服务器"></a>购买云服务器</h3><p>我使用的是<a target="_blank" rel="noopener" href="https://cloud.tencent.com/login?s_url=https://console.cloud.tencent.com/">腾讯云</a>, 配置：1核 1GB 1Mbps系统盘：普通云硬盘，Centos系统</p>
        
          <p class="article-more-link">
            <a href="/2020/03/21/InstallTomcat/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://iamlay.com/2020/03/21/InstallTomcat/" data-id="clfj8cp2c000hfbf364pm2mi3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Encrypt" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/21/Encrypt/" class="article-date">
  <time datetime="2019-03-21T08:16:20.000Z" itemprop="datePublished">2019-03-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/21/Encrypt/">iOS，一行代码进行RSA、DES 、AES、MD5加密、解密</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://github.com/iamlay/Encryptions">加密的Demo，欢迎下载</a></p>
<p>java端的加密解密，读者可以看我同事的<a target="_blank" rel="noopener" href="https://note.youdao.com/">这篇文章</a></p>
        
          <p class="article-more-link">
            <a href="/2019/03/21/Encrypt/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://iamlay.com/2019/03/21/Encrypt/" data-id="clfj8cp240004fbf362wsbtso" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cocoapodsVisual" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/21/cocoapodsVisual/" class="article-date">
  <time datetime="2019-03-21T08:16:20.000Z" itemprop="datePublished">2019-03-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/21/cocoapodsVisual/">cocoapods依赖关系可视化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://www.weichao.ren/ios/2018/12/27/cocoapods-graph/">转载</a></p>
<blockquote>
<p>cocoapods管理的三方库之间有时候存在依赖关系，Podfile.lock藏满了各个版本库的版本号信息和彼此的依赖关系。</p>
</blockquote>
<h3 id="网页可视化导出-cocoapods-graph"><a href="#网页可视化导出-cocoapods-graph" class="headerlink" title="网页可视化导出-cocoapods-graph"></a>网页可视化导出-cocoapods-graph</h3><p>终端安装插件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install cocoapods-graph</span><br></pre></td></tr></table></figure>
        
          <p class="article-more-link">
            <a href="/2019/03/21/cocoapodsVisual/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://iamlay.com/2019/03/21/cocoapodsVisual/" data-id="clfj8cp2p001nfbf39l1lcrz9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%91%A8%E6%8A%A5/">周报</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%AB%99/">网站</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ChatGPT/" rel="tag">ChatGPT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/ChatGPT/" style="font-size: 10px;">ChatGPT</a> <a href="/tags/%E5%8E%9F%E5%88%9B/" style="font-size: 20px;">原创</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 10px;">翻译</a> <a href="/tags/%E8%BD%AC%E8%BD%BD/" style="font-size: 15px;">转载</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/03/22/GPTRegister/">ChatGPT保姆级注册教程</a>
          </li>
        
          <li>
            <a href="/2022/10/16/PDFFindGuide/">PDF查找指导文档</a>
          </li>
        
          <li>
            <a href="/2022/04/17/MacRecommannd/">以技术之名周报10#｜推荐：Mac用户必备网站和App｜2022-04-17</a>
          </li>
        
          <li>
            <a href="/2022/04/11/EBookFind/">以技术之名周报09#｜如何高效的查找一本电子书｜2022-04-11</a>
          </li>
        
          <li>
            <a href="/2020/08/28/week2020-36/">以技术之名周报08#| Swift代码规范| 2020-08-28</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Ray<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>