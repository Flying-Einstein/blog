<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>以技术之名</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="为信仰而生">
<meta property="og:type" content="website">
<meta property="og:title" content="以技术之名">
<meta property="og:url" content="http://iamlay.com/index.html">
<meta property="og:site_name" content="以技术之名">
<meta property="og:description" content="为信仰而生">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ray">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="以技术之名" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">以技术之名</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://iamlay.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-GPTRegister" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/03/22/GPTRegister/" class="article-date">
  <time datetime="2023-03-22T04:22:30.000Z" itemprop="datePublished">2023-03-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/03/22/GPTRegister/">ChatGPT保姆级注册教程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-注册ChatGPT账号流程"><a href="#1-注册ChatGPT账号流程" class="headerlink" title="1.注册ChatGPT账号流程"></a>1.注册ChatGPT账号流程</h4><h5 id="1-1-购买VPN"><a href="#1-1-购买VPN" class="headerlink" title="1.1 购买VPN"></a>1.1 购买VPN</h5><blockquote>
<p>因为OpenAI公司的限制，并不是使用所有的VPN都可以注册ChatGPT的账号，需要选择那些可以更换节点的VPN，且可以更换成除香港节点以外的节点，比如：日本、新家坡等。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://customer-01.yhcvpn.xyz/#/register?code=MIWmxFG2">Fire Fly</a></p>
<p><strong>套餐选择</strong><br><img src="https://raw.githubusercontent.com/iamlay/BlogResources/main/Pictures01.png" alt="Alt text"><br><strong>使用文档</strong><br><img src="https://raw.githubusercontent.com/iamlay/BlogResources/main/PicturesGPTRegister02.png" alt="Alt text"><br><strong>节点切换</strong><br><img src="https://raw.githubusercontent.com/iamlay/BlogResources/main/PicturesGPTRegister03.png" alt="Alt text"></p>
<h5 id="1-2-购买能够接收短信的外国手机号"><a href="#1-2-购买能够接收短信的外国手机号" class="headerlink" title="1.2 购买能够接收短信的外国手机号"></a>1.2 购买能够接收短信的外国手机号</h5><blockquote>
<p>在注册ChatGPT账号的过程中，输入完邮箱和密码之后，需要验证手机号，因为ChatGPT是禁止国内手机号注册的，所以需要用到可以接收短信的国外手机号。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://sms-activate.org/?ref=5743767">虚拟号码短信接收平台</a><br>在该平台注册账号，并完成充值(支持支付宝充值，最低2美元，并收取0.1美元的服务费)，会在后面注册ChatGPT账号接收短信的时候用到</p>
<p><img src="https://raw.githubusercontent.com/iamlay/BlogResources/main/PicturesGPTRegister04.png" alt="Alt text"></p>
<p><strong>余额充值</strong><br><img src="https://raw.githubusercontent.com/iamlay/BlogResources/main/PicturesGPTRegister05.png" alt="Alt text"></p>
<h5 id="1-3注册流程"><a href="#1-3注册流程" class="headerlink" title="1.3注册流程"></a>1.3注册流程</h5><p><a target="_blank" rel="noopener" href="https://chat.openai.com/auth/login">官网注册入口</a></p>
<p><strong>输入邮箱和密码</strong></p>
<blockquote>
<p>不要使用163的邮箱，会出现报错的问题，尽量使用QQ邮箱或者谷歌邮箱，点击Continue之后，会发送邮件到邮箱，点击验证，验证通过会继续下一步</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/iamlay/BlogResources/main/PicturesGPTRegister06.png" alt="Alt text"></p>
<p><strong>输入用户名</strong></p>
<blockquote>
<p>输入完用户名，下一步会进入到验证手机号的页面</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/iamlay/BlogResources/main/PicturesGPTRegister07.png" alt="Alt text"></p>
<p><strong>验证手机号</strong></p>
<blockquote>
<p>1、验证手机号的时候，先去<a target="_blank" rel="noopener" href="https://sms-activate.org/?ref=5743767">虚拟手机号短信接收平台</a>查看支持哪些国家。第一步先选择OpenAI服务 - &gt; 选择国家加入购物车 -&gt; 点击拷贝按钮拷贝手机号，不要关闭该页面，等待接收短信。<br>2、然后在ChatGPT的手机号验证页面选择对应的国家，并将手机号粘贴进去，注意粘贴的时候会吧区号也粘进去，注意删掉</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/iamlay/BlogResources/main/PicturesGPTRegister08.png" alt="Alt text"></p>
<p><em>手机号验证页面 - 选择国家</em><br><img src="https://raw.githubusercontent.com/iamlay/BlogResources/main/PicturesGPTRegister09.png" alt="Alt text"></p>
<p><em>手机号验证页面 - 粘贴手机号</em></p>
<blockquote>
<p>注意，这里要选择NO, 否则短信验证码会发送到WhatsApp,  SMS平台接收不到短信，然后点击 Send code via SMS 接收短信</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/iamlay/BlogResources/main/PicturesGPTRegister10.png" alt="Alt text"></p>
<p><em>短信接收平台- 接收短信</em></p>
<blockquote>
<p>上一步发送验证码之后，刷新短信验证平台的页面，就可以看到接收到的短信验证码，拷贝到ChatGPT平台验证就可以验证成功</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/iamlay/BlogResources/main/PicturesGPTRegister11.png" alt="Alt text"></p>
<p>完成上面的步骤，ChatGPT账号即可注册成功，可以正常使用ChatGPT进行聊天。</p>
<h4 id="2-关于API-Key"><a href="#2-关于API-Key" class="headerlink" title="2.关于API Key"></a>2.关于API Key</h4><blockquote>
<p>目前除了ChatGPT之外, 很多应用也基于GPT-3.5或GPT-4.0提供相关的服务，在使用这些应用的时候，经常会要求输入个人的API key，可以登录下面这个OpenAI的页面生成个人的API Key,  登录账号跟注册的ChatGPT是同一个账号</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://platform.openai.com/account/api-keys">API Key获取页面</a></p>
<p><img src="https://raw.githubusercontent.com/iamlay/BlogResources/main/PicturesGPTRegister12.png" alt="Alt text"></p>
<h4 id="3-一些实用的ChatGPT应用"><a href="#3-一些实用的ChatGPT应用" class="headerlink" title="3.一些实用的ChatGPT应用"></a>3.一些实用的ChatGPT应用</h4><h5 id="1-Google浏览器插件-Chat-GPT-For-Google"><a href="#1-Google浏览器插件-Chat-GPT-For-Google" class="headerlink" title="1. Google浏览器插件 - Chat GPT For Google"></a>1. Google浏览器插件 - <a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/chatgpt-for-google/jgjaeacdkonaoafenlfkkkmbaopkbilf">Chat GPT For Google</a></h5><p><a target="_blank" rel="noopener" href="https://zblogs.top/chatgpt-for-google/">安装教程</a></p>
<blockquote>
<p> ChatGPT For Google插件是一款可以在Google Chrome浏览器上使用的聊天机器人插件，它基于OpenAI的强大语言模型GPT，可以进行自然语言对话，提供有趣的聊天体验。<br><img src="https://raw.githubusercontent.com/iamlay/BlogResources/main/PicturesGPTRegister13.png" alt="Alt text"></p>
</blockquote>
<h5 id="2-Google浏览器插件-OpenAI-Translator"><a href="#2-Google浏览器插件-OpenAI-Translator" class="headerlink" title="2. Google浏览器插件 - OpenAI Translator"></a>2. Google浏览器插件 - <a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/openai-translator/ogjibjphoadhljaoicdnjnmgokohngcc">OpenAI Translator</a></h5><blockquote>
<p>这是一个使用 ChatGPT API 进行划词翻译和文本润色的浏览器插件。借助了 ChatGPT 强大的翻译能力，它将帮助您更流畅地阅读外语和编辑外语<br><img src="https://raw.githubusercontent.com/iamlay/BlogResources/main/PicturesGPTRegister14.png" alt="Alt text"></p>
</blockquote>
<h5 id="3-编程辅助插件-GitHub-Copilot"><a href="#3-编程辅助插件-GitHub-Copilot" class="headerlink" title="3.编程辅助插件 - GitHub Copilot"></a>3.编程辅助插件 - <a target="_blank" rel="noopener" href="https://github.com/features/copilot/">GitHub Copilot</a></h5><blockquote>
<p>GitHub Copilot 是一种 AI 工具，可根据命名或者正在编辑的代码上下文为开发者提供代码建议。根据官方介绍，Copilot 已经接受了来自 GitHub 上公开可用存储库的数十亿行代码的训练，它支持大多数编程语言，但官方建议使用 Python、JavaScript、TypeScript、Ruby 和 Go。Copilot 是 GitHub 和OpenAI合作的结果， OpenAI得到了微软的大力支持。它由一个名为 Codex 的全新 AI 系统提供支持，该系统基于 GPT-3 模型。GPT-3代表第三代 Generative Pre-trained Transformer——一种能够从简单提示生成文本序列的语言模型。Codex 源自此模型，它不仅可以处理文本，还可以生成一些最流行语言的代码。<a target="_blank" rel="noopener" href="https://juejin.cn/post/7069605069385105421">详细介绍</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/iamlay/BlogResources/main/PicturesGPTRegister15.gif" alt="官方介绍"></p>
<p><a target="_blank" rel="noopener" href="https://docs.github.com/en/copilot">支持Copilot的IDE</a><br><img src="https://raw.githubusercontent.com/iamlay/BlogResources/main/PicturesGPTRegister16.png" alt="Alt text"></p>
<p>目前<a target="_blank" rel="noopener" href="https://github.com/features/copilot/">GitHub Copilot</a>是收费版本，10$每月，但对于学生是免费的，万能的淘宝上有Github学生优惠企业店，我注册了一个学生账号2年25块左右，可以免费使用<a target="_blank" rel="noopener" href="https://github.com/features/copilot/">GitHub Copilot</a>，以及JetBrains全家桶。</p>
<h5 id="4-基于GPT-4-0的IDE-Cursor"><a href="#4-基于GPT-4-0的IDE-Cursor" class="headerlink" title="4.基于GPT-4.0的IDE - Cursor"></a>4.基于GPT-4.0的IDE - <a target="_blank" rel="noopener" href="https://www.cursor.so/">Cursor</a></h5><blockquote>
<p>cursor.so 是一个适合程序员编码的，且集成了 GPT-4 的免费 IDE 工具（目前免费），可以帮助用户快速编写、编辑和优化代码。cursor.so 支持主流的编程语言，并且可以根据用户的输入描述自动生成满足需求的代码片段。cursor.so 还可以帮助用户优化和重构代码，或者为陌生的代码添加注释以帮助理解代码，提高开发效率。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.dongwm.com/post/how-to-use-cursor-ide/">使用基于GPT-4模型的IDE: Cursor用法全解读</a><br><img src="https://raw.githubusercontent.com/iamlay/BlogResources/main/PicturesGPTRegister17.png" alt="Alt text"></p>
<h4 id="4-一个好玩的ChatGPT应用"><a href="#4-一个好玩的ChatGPT应用" class="headerlink" title="4.一个好玩的ChatGPT应用"></a>4.一个好玩的ChatGPT应用</h4><h5 id="1-AI室内设计-RoomGPT"><a href="#1-AI室内设计-RoomGPT" class="headerlink" title="1. AI室内设计 - RoomGPT"></a>1. AI室内设计 - <a target="_blank" rel="noopener" href="https://www.roomgpt.io/">RoomGPT</a></h5><blockquote>
<p>你只需要给你的房间拍一张照，或是房间的 3D 效果图，并将其上传，即可用 AI 生成对应的梦幻房间效果图。</p>
</blockquote>
<p> <img src="https://raw.githubusercontent.com/iamlay/BlogResources/main/PicturesGPTRegister18.png" alt="Alt text"></p>
<h4 id="5-其他实用AI工具"><a href="#5-其他实用AI工具" class="headerlink" title="5.其他实用AI工具"></a>5.其他实用AI工具</h4><h5 id="智能绘图-ProcessOn智能绘图"><a href="#智能绘图-ProcessOn智能绘图" class="headerlink" title="智能绘图 - ProcessOn智能绘图"></a>智能绘图 - <a target="_blank" rel="noopener" href="https://www.processon.com/diagrams">ProcessOn智能绘图</a></h5><blockquote>
<p>输入主题关键词，只需一键，「帮你创作」流程图，围绕主题的流程图会跃然纸上，内容简洁清晰，逻辑直观严谨，简化了绘制流程，降低了创作门槛，提高了创作速度，革新了创作模式，又尽可能保证了内容的客观性和通用性。<br>输入主题关键词，只需一键，「帮你创作」思维导图，3秒完成辞简义赅的内容大纲，如脑机交互，突破灵感边界，收获优质答卷，享受极致体验。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/iamlay/BlogResources/main/PicturesGPTRegister19.gif" alt="Alt text"></p>
<p>如果您在申请账号的过程中有任何问题，请在下面的评论区留言</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://iamlay.com/2023/03/22/GPTRegister/" data-id="clfj8cp250005fbf34t1l03xy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ChatGPT/" rel="tag">ChatGPT</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-PDFFindGuide" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/10/16/PDFFindGuide/" class="article-date">
  <time datetime="2022-10-16T04:07:46.000Z" itemprop="datePublished">2022-10-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/10/16/PDFFindGuide/">PDF查找指导文档</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>开篇： 史上最全的PDF查找文档</p>
</blockquote>
        
          <p class="article-more-link">
            <a href="/2022/10/16/PDFFindGuide/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://iamlay.com/2022/10/16/PDFFindGuide/" data-id="clfj8cp2n001efbf3akevf3o4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MacRecommannd" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/17/MacRecommannd/" class="article-date">
  <time datetime="2022-04-17T04:53:18.000Z" itemprop="datePublished">2022-04-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%91%A8%E6%8A%A5/">周报</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/17/MacRecommannd/">以技术之名周报10#｜推荐：Mac用户必备网站和App｜2022-04-17</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>作为一个iOS开发者&amp;Mac的深度用户，跟Mac打交道是工作日常，今天给大家推荐几个对我来讲非常有效率的网站和应用，希望对各位Mac用户有比较大的帮助。</p>
</blockquote>
<h3 id="推荐一：全世界最大的数字图书馆-Z-Library"><a href="#推荐一：全世界最大的数字图书馆-Z-Library" class="headerlink" title="推荐一：全世界最大的数字图书馆 - Z-Library"></a>推荐一：全世界最大的数字图书馆 - <a target="_blank" rel="noopener" href="https://zh.u1lib.org/">Z-Library</a></h3><ul>
<li>完全免费，且无广告</li>
<li>电子书资源丰富，1000多万本电子书和8000多万篇期刊和文章，且还在持续更新中</li>
<li>支持各种格式电子书和格式转换</li>
</ul>
<p><img src="/MacRecommannd01.jpeg" alt="Z-Library"></p>
<h3 id="推荐二：Mac软件下载网站-Macwk（下面推荐的软件都可在改网站下载）"><a href="#推荐二：Mac软件下载网站-Macwk（下面推荐的软件都可在改网站下载）" class="headerlink" title="推荐二：Mac软件下载网站 - Macwk（下面推荐的软件都可在改网站下载）"></a>推荐二：Mac软件下载网站 - <a target="_blank" rel="noopener" href="https://www.macwk.com/article/office-for-macos-install">Macwk</a>（下面推荐的软件都可在改网站下载）</h3><ul>
<li>软件支持直接下载且不限速，不需要使用各种网盘工具来下</li>
<li>无广告，网站干净整洁、分类清晰</li>
<li>软件质量高，都属精品</li>
<li>软件安装过程很人性化，会有一些有用的安装提示</li>
</ul>
<p><img src="/MacRecommannd02.jpeg" alt="网站截图"></p>
<h3 id="推荐三：-新一代效率工具平台-UTools"><a href="#推荐三：-新一代效率工具平台-UTools" class="headerlink" title="推荐三： 新一代效率工具平台: UTools"></a>推荐三： 新一代效率工具平台: <a target="_blank" rel="noopener" href="https://u.tools/">UTools</a></h3><ul>
<li>提供了优秀的插件化设计，让你可以自取所需，任意组合各种插件</li>
<li>可以大大提升程序员开发效率，比如具备一些Json编译器和MarkDown笔记编辑器，</li>
</ul>
<p><img src="/MacRecommannd03.jpeg" alt="UTools"></p>
<h3 id="推荐四：在线视频下载器-Downie"><a href="#推荐四：在线视频下载器-Downie" class="headerlink" title="推荐四：在线视频下载器:Downie"></a>推荐四：在线视频下载器:<a target="_blank" rel="noopener" href="https://software.charliemonroe.net/downie/">Downie</a></h3><blockquote>
<p>Downie for Mac 是一款Mac OS平台上最好用的Mac视频下载工具，Downie for mac 破解版支持1000多个不同的视频网站，支持国内的优酷、腾讯视频、bilibili、土豆、爱奇艺、网易、搜狐、微博以及国外的Youtube、Twitter等在线视频网站视频下载，功能强大使用简单。</p>
</blockquote>
<p><img src="/MacRecommannd04.jpeg" alt="Downie"></p>
<h3 id="推荐五：PDF阅读器-PDF-Expert"><a href="#推荐五：PDF阅读器-PDF-Expert" class="headerlink" title="推荐五：PDF阅读器- PDF Expert"></a>推荐五：PDF阅读器- <a target="_blank" rel="noopener" href="https://pdfexpert.com/">PDF Expert</a></h3><blockquote>
<p>PDF Expert 是Mac的最好用的PDF编辑器。你可以方便快速的编辑文本，图像和链接。它会自动检测文本的字体，大小和不透明度等。</p>
</blockquote>
<p><img src="/MacRecommannd05.jpeg" alt="PDF Expert"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://iamlay.com/2022/04/17/MacRecommannd/" data-id="clfj8cp2i000zfbf3d71h9qhp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-EBookFind" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/11/EBookFind/" class="article-date">
  <time datetime="2022-04-11T13:18:17.000Z" itemprop="datePublished">2022-04-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%91%A8%E6%8A%A5/">周报</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/11/EBookFind/">以技术之名周报09#｜如何高效的查找一本电子书｜2022-04-11</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Part01-背景简介"><a href="#Part01-背景简介" class="headerlink" title="Part01 - 背景简介"></a>Part01 - 背景简介</h3><blockquote>
<p>关于为什么放弃纸质版书籍，不同的群体痛点不同，但是不管怎样，我们最终走向了相同的道路 — 在互联网这片大海里捞针。</p>
</blockquote>
<ul>
<li>你有没有花费几个小时找不到需要电子书的痛苦经历？</li>
<li>你有没有好不容易辛辛苦苦找到一本电子书，却要继续面临关注公众号、注册用户、购买下载积分的糟糕旅程？</li>
<li>你有没有遭遇过在百度搜索电子书，挨个点击网页最终都跳转到同一个垃圾网站的恶心时刻？</li>
<li>你有想看的电子书的时候，想不想立刻下载下来马上开启一段愉快的读书旅程？</li>
</ul>
<p>如果你遭遇过以上，也许这套方案不能解决你100%的问题，但是至少可以解决90%的问题，希望我个人的一些实践，对想读书的你有一些帮助。</p>
<h3 id="Part02-网站介绍"><a href="#Part02-网站介绍" class="headerlink" title="Part02 - 网站介绍"></a>Part02 - 网站介绍</h3><p>实际上，在网上查找电子书的过程中，我使用过非常多的电子书网站，每个网站有不同的优势，电子书资源也不尽相同。原本想将比较优秀的电子书网站都介绍一下，但是难免会陷入摊大饼的模式之中，大家会找不到重点，对大家来说保存大量的电子书网站也不是一个很好的用户体验。<br>寻书人的痛苦总是相似的，最近发现了一个令人兴奋电子书网站<a target="_blank" rel="noopener" href="https://xmsoushu.com/#/">熊猫搜书</a>，这个网站集合了常用的大部分电子书网站，大家保存这一个网站就可以了，搜索的时候切换不同的网站就可。<br>不过，我仍旧会推荐其中两个我最常用的网站<a target="_blank" rel="noopener" href="https://zh.book4you.org/">Z-library</a>和 <a target="_blank" rel="noopener" href="https://www.jiumodiary.com/">鸠摩搜索</a>，这两个网站能解决我90%以上的需求，我相信对大家亦是如此。</p>
<p><strong>熊猫搜书：</strong><br>熊猫搜索这个网站本身支持搜索，但是最大的优势是集合了所有电子书网站的入口(如下面截图)，界面简单<br>熊猫搜索到的资源最终是存在各种网盘之上的，可根据需要下载自己需要的图书资源<br>​<br><img src="/EBook001.jpeg" alt="熊猫搜索官网"></p>
<p><strong>Z-Library（全世界最大的电子图书馆）：</strong></p>
<ul>
<li>科研党必备</li>
<li>成立于2009年，全世界最大的数字图书馆，支持期刊文章和各类型电子书的搜索和下载，图书总量超过1000万册，文章数量8000多万篇。</li>
<li>支持通过作者、图书名字、ISBN、出版社、MD5进行检索。支持通过短语和单词进行全文检索，英文原版电子文档很多，是搞科研、写论文的神器。</li>
<li>可以不注册，但是注册会员享有更多的功能：比如电子书格式转换，提升单日下载量、发送到kindle等</li>
</ul>
<p><img src="/EBook002.png" alt="Z-Library官网"><br>​</p>
<p><strong>鸠摩搜索：</strong></p>
<ul>
<li>鸠摩搜索是一个聚合引擎，主要是聚合了百度和bing两个搜索引擎。搜索的站点包括：豆瓣、淘宝、百度文库、百度云、百度网盘、国学大师、微盘、新浪爱问、孔夫子网、国家数字图书馆、喜马拉雅有声阅读、大学图书馆等站点。</li>
<li>鸠摩搜索可以作为Z-Library网站之外的一个有力的补充，搜索结果中包含了纸质书正版和二手书的购买链接, 价格相对较低，有些比较新的书确实没有电子版，可以考虑通过该链接来购买。<br>​<br><img src="/EBook003.jpeg" alt="鸠魔搜索官网"></li>
</ul>
<h3 id="Part03-科学上网"><a href="#Part03-科学上网" class="headerlink" title="Part03 - 科学上网"></a>Part03 - 科学上网</h3><p>正常情况下，通过上面的网站应该已经可以查找到我们需要的电子书，有一些书或者文章通过上面的方式还是查找不到，我们还有一种兜底方案：科学上网。通过Google搜索根据关键词检索我们需要的资源。也许你会问，我用百度可以吗？ 我们看一下检索同一本电子书谷歌和百度给出的结果。<br>​<br><img src="/EBook004.jpeg" alt="来自谷歌搜索"></p>
<p>​<img src="/EBook005.jpeg" alt="来自百度搜索"></p>
<p>科学上网工具五花八门，评价一款科学上网工具好不好可以从四个维度： 价格、稳定性、支持跨平台（Mac、Windows、iPhone、Andriod)、操作简单。<br>关于如何科学上网，大家可以看<a href="https://iamlay.com/2020/06/25/VPN/">这篇文章</a></p>
<h3 id="Part04-最佳实践"><a href="#Part04-最佳实践" class="headerlink" title="Part04 - 最佳实践"></a>Part04 - 最佳实践</h3><p>读电子书，能方便的做读书笔记是非常重要的一项内容，一款好的电子书阅读软件能够极大的节省我们的时间，提升我们的阅读体验。个人作为Mac用户，推荐一下个人实践。<br>​​<img src="/EBook006.jpeg" alt="最佳实践"></p>
<ul>
<li><p>个人推荐Mac用户在下载电子书的时候，优先下载<code>EPUB</code>格式的电子书，Mac自带的图书软件其实非常优秀，支持最好的就是EPUB格式的电子书，PDF虽然也支持，但是如果文件过大，会出现打不开直接闪退的问题。</p>
</li>
<li><p>如果没有找到EPUB格式的电子书或者PDF转成的EPUB效果不好，可以使用PDF格式的电子书。个人比较推荐<code>PDF Expert</code>这款软件，页面非常的简洁。</p>
</li>
</ul>
<h3 id="Part05-一个彩蛋"><a href="#Part05-一个彩蛋" class="headerlink" title="Part05 - 一个彩蛋"></a>Part05 - 一个彩蛋</h3><p>免费版本的<code>Xmind</code>和<code>ClearView</code>都可以在<a target="_blank" rel="noopener" href="https://www.macwk.com/">MacWk网站</a>下载，常用的Mac破解软件都可以在这个网站下载，大家可以自己去这个良心网站探索，破解版本的软件都更新的非常及时。<br>​<br>​​​<img src="/EBook007.jpeg" alt="MacWk官网"></p>
<h3 id="Part06-结束语"><a href="#Part06-结束语" class="headerlink" title="Part06 - 结束语"></a>Part06 - 结束语</h3><p>书能给人以知识，给人以智慧，给人以快乐，给人以希望。 希望每个读书人都有一段快乐的旅程！！！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://iamlay.com/2022/04/11/EBookFind/" data-id="clfj8cp260006fbf38bvg5gm7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-week2020-36" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/28/week2020-36/" class="article-date">
  <time datetime="2020-08-28T06:36:38.000Z" itemprop="datePublished">2020-08-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/28/week2020-36/">以技术之名周报08#| Swift代码规范| 2020-08-28</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Part-01-代码格式"><a href="#Part-01-代码格式" class="headerlink" title="Part-01:  代码格式"></a>Part-01:  代码格式</h4><ul>
<li>1.1使用4个空格替代一个<code>Tabs</code></li>
<li>1.2 单行过长会引起阅读不适，每行代码尽量限制在 160 字符内 （<code>Xcode -&gt; Preferences -&gt; Text Editing -&gt; Page guide at column</code>设置为 160 将会很有帮助</li>
<li>1.3 确保每个文件末尾都有一个新行</li>
<li>1.4 确保任何地方都没有尾随的空格（ <code>Xcode -&gt; Preferences -&gt; Text Editing -&gt; Automatically trim trailing whitespace 加上 Including whitespace-only lines </code>）</li>
<li>不要把左大括号放在新行 — 我们使用 <a target="_blank" rel="noopener" href="https://en.m.wikipedia.org/wiki/Indentation_style#1TBS">1TBS 风格</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class SomeClass &#123;</span><br><span class="line">    func someMethod() &#123;</span><br><span class="line">        if x == y &#123;</span><br><span class="line">            /* ... */</span><br><span class="line">        &#125; else if x == z &#123;</span><br><span class="line">            /* ... */</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /* ... */</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* ... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>1.6 当为属性、常量、变量、字典的键、函数参数、协议实现或父类书写类型时，不要在冒号<code>:</code>前面加上空格<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 指明类型</span><br><span class="line">let pirateViewController: PirateViewController</span><br><span class="line"></span><br><span class="line">// 字典语法（注意我们左对齐而不是对齐冒号）</span><br><span class="line">let ninjaDictionary: [String: AnyObject] = [</span><br><span class="line">    &quot;fightLikeDairyFarmer&quot;: false,</span><br><span class="line">    &quot;disgusting&quot;: true</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// 声明函数</span><br><span class="line">func myFunction&lt;T, U: SomeProtocol&gt;(firstArgument: U, secondArgument: T) where T.RelatedType == U &#123;</span><br><span class="line">    /* ... */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用函数</span><br><span class="line">someFunction(someArgument: &quot;Kitten&quot;)</span><br><span class="line"></span><br><span class="line">// 父类</span><br><span class="line">class PirateViewController: UIViewController &#123;</span><br><span class="line">    /* ... */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 协议</span><br><span class="line">extension PirateViewController: UITableViewDataSource &#123;</span><br><span class="line">    /* ... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>1.7 通常， , 逗号后面应该有一个空格。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let myArray = [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure></li>
<li>1.8 二元运算符前后都应该有一个空格，比如 + 、 &#x3D;&#x3D; 或 -&gt;。当然， ( 后面和 ) 前面就不要有空格了<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let myValue = 20 + (30 / 2) * 3</span><br><span class="line">if 1 + 1 == 3 &#123;</span><br><span class="line">    fatalError(&quot;The universe is broken.&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func pancake(with syrup: Syrup) -&gt; Pancake &#123;</span><br><span class="line">    /* ... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>1.9 我们遵循 Xcode 推荐的缩进风格（即按住 CTRL-I 时，代码不再发生变化）。当声明的函数跨越多行时，推荐使用 Xcode 7.3 默认的语法风格<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 针对跨行函数声明，Xcode 添加了缩进</span><br><span class="line">func myFunctionWithManyParameters(parameterOne: String,</span><br><span class="line">                                  parameterTwo: String,</span><br><span class="line">                                  parameterThree: String) &#123;</span><br><span class="line">    // 对于这种语句，Xcode 缩进到这</span><br><span class="line">    print(&quot;\(parameterOne) \(parameterTwo) \(parameterThree)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 针对多行的 `if` 语句增加换行缩进</span><br><span class="line">if myFirstValue &gt; (mySecondValue + myThirdValue)</span><br><span class="line">    &amp;&amp; myFourthValue == .someEnumValue &#123;</span><br><span class="line"></span><br><span class="line">    // 这行语句缩进到这</span><br><span class="line">    print(&quot;Hello, World!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>1.10 当调用一个多参数函数时，将每个参数放置有额外缩进的单独行中<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">someFunctionWithManyArguments(</span><br><span class="line">    firstArgument: &quot;Hello, I am a string&quot;,</span><br><span class="line">    secondArgument: resultFromSomeFunction(),</span><br><span class="line">    thirdArgument: someOtherLocalProperty)</span><br></pre></td></tr></table></figure></li>
<li>1.11 处理大到足以分成多行的隐式数组或字典时，按照方法、if 语句等语法中大括号的风格使用 <code>[</code> 和<code>]</code>方法中的闭包也应该用类似的风格处理<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">someFunctionWithABunchOfArguments(</span><br><span class="line">    someStringArgument: &quot;hello I am a string&quot;,</span><br><span class="line">    someArrayArgument: [</span><br><span class="line">        &quot;dadada daaaa daaaa dadada daaaa daaaa dadada daaaa daaaa&quot;,</span><br><span class="line">        &quot;string one is crazy - what is it thinking?&quot;</span><br><span class="line">    ],</span><br><span class="line">    someDictionaryArgument: [</span><br><span class="line">        &quot;dictionary key 1&quot;: &quot;some value 1, but also some more text here&quot;,</span><br><span class="line">        &quot;dictionary key 2&quot;: &quot;some value 2&quot;</span><br><span class="line">    ],</span><br><span class="line">    someClosure: &#123; parameter1 in</span><br><span class="line">        print(parameter1)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li>
<li>1.12 尽可能避免多行语句，推荐使用局部常量或其他方法。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">let firstCondition = x == firstReallyReallyLongPredicateFunction()</span><br><span class="line">let secondCondition = y == secondReallyReallyLongPredicateFunction()</span><br><span class="line">let thirdCondition = z == thirdReallyReallyLongPredicateFunction()</span><br><span class="line">if firstCondition &amp;&amp; secondCondition &amp;&amp; thirdCondition &#123;</span><br><span class="line">    // 做某事</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">if x == firstReallyReallyLongPredicateFunction()</span><br><span class="line">    &amp;&amp; y == secondReallyReallyLongPredicateFunction()</span><br><span class="line">    &amp;&amp; z == thirdReallyReallyLongPredicateFunction() &#123;</span><br><span class="line">    // 做某事</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Part-02-命名规范"><a href="#Part-02-命名规范" class="headerlink" title="Part-02:  命名规范"></a>Part-02:  命名规范</h4><ul>
<li><p>2.1 在 Swift 中不需要 Objective-C 风格的前缀（比如用 <code>GuybrushThreepwood</code> 代替 <code>LIGuybrushThreepwood</code>)</p>
</li>
<li><p>2.2 使用<code> PascalCase</code> 为类型命名（比如 <code>struct</code> 、 <code>enum </code>、<code>class</code>、 <code>typedef</code> 、 <code>associatedtype </code>等等）。</p>
</li>
<li><p>2.3 对于函数、方法、属性、常量、变量、参数名称、枚举选项，使用 <code>camelCase </code>（首字母小写）。</p>
</li>
<li><p>2.4 实际上，当处理通常全部大写的缩写或其他名称时，代码里用到的任何名称都使用大写。例外情况是，如果这个单词位于以需要用小写开头的名称的开头 —— 在这种情况下，请使用全部小写字母作为首字母缩写词</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 「HTML」是常量名称的开头，所以我们使用小写「html」 </span><br><span class="line">let htmlBodyContent: String = &quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;</span><br><span class="line">// 推荐使用 ID 而不是 Id</span><br><span class="line">let profileID: Int = 1</span><br><span class="line">// 推荐 URLFinder 而不是 UrlFinder</span><br><span class="line">class URLFinder &#123;</span><br><span class="line">    /* ... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>2.5 所有与实例无关的常量都应该用 static 修饰。所有这些 static 常量都应该放置在他们的 class 、 struct 或 enum 标记过的部分中。 对于有很多常量的类，你应该将拥有类似或相同前缀、后缀 和 &#x2F; 或者使用情况的常量进行分组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 推荐    </span><br><span class="line">class MyClassName &#123;</span><br><span class="line">    // MARK: - 常量</span><br><span class="line">    static let buttonPadding: CGFloat = 20.0</span><br><span class="line">    static let indianaPi = 3</span><br><span class="line">    static let shared = MyClassName()</span><br><span class="line">&#125;</span><br><span class="line">// 不推荐</span><br><span class="line">class MyClassName &#123;</span><br><span class="line">    // 不要使用 `k` 前缀</span><br><span class="line">    static let kButtonPadding: CGFloat = 20.0</span><br><span class="line"></span><br><span class="line">    // 不用为常量使用命名空间</span><br><span class="line">    enum Constant &#123;</span><br><span class="line">        static let indianaPi = 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>2.6 对于泛型和关联类型，使用 PascalCase 描述泛型。如果这个单词和它遵循的协议或者它继承的父类冲突，你可以在关联类型或泛型名称后面追加 Type 后缀。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class SomeClass&lt;Model&gt; &#123; /* ... */ &#125;</span><br><span class="line">protocol Modelable &#123;</span><br><span class="line">    associatedtype Model</span><br><span class="line">&#125;</span><br><span class="line">protocol Sequence &#123;</span><br><span class="line">    associatedtype IteratorType: Iterator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>2.7 名称应具有描述性的和明确性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">class RoundAnimatingButton: UIButton &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">class CustomButton: UIButton &#123; /* ... */ &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>2.8 不要缩写、使用缩写名称或单字母名称</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">class RoundAnimatingButton: UIButton &#123;</span><br><span class="line">    let animationDuration: NSTimeInterval</span><br><span class="line"></span><br><span class="line">    func startAnimating() &#123;</span><br><span class="line">        let firstSubview = subviews.first</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">class RoundAnimating: UIButton &#123;</span><br><span class="line">    let aniDur: NSTimeInterval</span><br><span class="line"></span><br><span class="line">    func srtAnmating() &#123;</span><br><span class="line">        let v = subviews.first</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>2.9 如果不明显，请在常量或变量名称中包含类型信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">class ConnectionTableViewCell: UITableViewCell &#123;</span><br><span class="line">    let personImageView: UIImageView</span><br><span class="line"></span><br><span class="line">    let animationDuration: TimeInterval</span><br><span class="line"></span><br><span class="line">    // 由于属性名称明显可以看出它是字符串，在实例变量名称中就可以不包含字符串了。</span><br><span class="line">    let firstName: String</span><br><span class="line"></span><br><span class="line">    // 虽然不推荐，但使用 `Controller` 代替 `ViewController` 也是可以的。</span><br><span class="line">    let popupController: UIViewController</span><br><span class="line">    let popupViewController: UIViewController</span><br><span class="line"></span><br><span class="line">    // 当使用 `UIViewController` 的子类时，例如 table view controller、    </span><br><span class="line">        // collection view controller 、 split view controller 等，</span><br><span class="line">    // 在名称中完整表明其类型</span><br><span class="line">    let popupTableViewController: UITableViewController</span><br><span class="line"></span><br><span class="line">    // 当使用 outlet 时，确保在属性名称中指明 outlet 的类型。</span><br><span class="line">    @IBOutlet weak var submitButton: UIButton!</span><br><span class="line">    @IBOutlet weak var emailTextField: UITextField!</span><br><span class="line">    @IBOutlet weak var nameLabel: UILabel!</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">class ConnectionTableViewCell: UITableViewCell &#123;</span><br><span class="line">    // 这不是 `UIImage` 所以不应该被叫做 image 而应该使用 </span><br><span class="line">        // personImageView</span><br><span class="line">    let personImage: UIImageView</span><br><span class="line"></span><br><span class="line">    // 这不是 `String`，所以它应该叫做 `textLabel`</span><br><span class="line">    let text: UILabel</span><br><span class="line"></span><br><span class="line">    // `animation` 没有很清晰地表明是时间间隔</span><br><span class="line">    // 使用 `animationDuration` 或 `animationTimeInterval` 代替它</span><br><span class="line">    let animation: TimeInterval</span><br><span class="line"></span><br><span class="line">    // `transition` 没有很明显地表明是 `String`</span><br><span class="line">    // 使用 `transitionText` 或 `transitionString` 代替它</span><br><span class="line">    let transition: String</span><br><span class="line"></span><br><span class="line">    // 这是 view controller — 而不是 view</span><br><span class="line">    let popupView: UIViewController</span><br><span class="line"></span><br><span class="line">    // 如前所述，我们不想使用缩写，所以不要用 `VC` 代替 `ViewController`</span><br><span class="line">    let popupVC: UIViewController</span><br><span class="line"></span><br><span class="line">    // 虽然在技术上这仍然是 `UIViewController`，但这个属性应该表明我们正在使用 *Table* View Controller</span><br><span class="line">    let popupViewController: UITableViewController</span><br><span class="line"></span><br><span class="line">    // 为了一致性，你应该把类型名称放在属性名称的结尾而不是开头。</span><br><span class="line">    @IBOutlet weak var btnSubmit: UIButton!</span><br><span class="line">    @IBOutlet weak var buttonSubmit: UIButton!</span><br><span class="line"></span><br><span class="line">    // 当处理 outlet 时，我们应该总是在属性名称中含有类型。</span><br><span class="line">    // 例如，我们应该用 `firstNameLabel` 代替。</span><br><span class="line">    @IBOutlet weak var firstName: UILabel!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>2.10 命名函数参数时，请确保函数可以被轻易地阅读并理解每个参数的目的</p>
</li>
<li><p>2.11 按照 Apple 的 API 设计规范，如果<code>protocol</code>描述「某事物在做什么」，那么应被命名为名词（比如 <code>Collection</code> ）。 如果<code>protocol</code>描述「一种能力」，使用后缀 <code>able</code> 、<code> ible</code> 或<code> ing</code>（比如 <code>Equatable</code> 、<code>ProgressReporting</code> ）。如果两种选项都不适用你的用例，你也可以在协议名称后加一个 <code>Protocol</code> 后缀。一些<code>protocol</code>的例子如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 这里的名称是描述「协议在做什么」的名词。</span><br><span class="line">protocol TableViewSectionProvider &#123;</span><br><span class="line">    func rowHeight(at row: Int) -&gt; CGFloat</span><br><span class="line">    var numberOfRows: Int &#123; get &#125;</span><br><span class="line">    /* ... */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这里的协议是一种能力，我们恰当地命名它。</span><br><span class="line">protocol Loggable &#123;</span><br><span class="line">    func logCurrentState()</span><br><span class="line">    /* ... */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 假设有个 `InputTextView` 类，但我们也想让协议概括一些能力—使用 `Protocol` 后缀非常恰当。</span><br><span class="line">protocol InputTextViewProtocol &#123;</span><br><span class="line">    func sendTrackingEvent()</span><br><span class="line">    func inputText() -&gt; String</span><br><span class="line">    /* ... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Part-03-编码风格"><a href="#Part-03-编码风格" class="headerlink" title="Part-03:  编码风格"></a>Part-03:  编码风格</h4><h5 id="3-1-通用"><a href="#3-1-通用" class="headerlink" title="3.1 通用#"></a>3.1 通用#</h5><ul>
<li><p>3.1.1 尽可能选择<code>let</code>而非<code>var</code></p>
</li>
<li><p>3.1.2 当从一个集合转换到另一个集合时，建议首选<code>map</code>，<code>filter</code>，<code> reduce</code> 等高阶函数。在使用这些方法时，请确保使用的闭包没有任何副作用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">let stringOfInts = [1, 2, 3].flatMap &#123; String($0) &#125;</span><br><span class="line">// [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">var stringOfInts: [String] = []</span><br><span class="line">for integer in [1, 2, 3] &#123;</span><br><span class="line">    stringOfInts.append(String(integer))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 推荐</span><br><span class="line">let evenNumbers = [4, 8, 15, 16, 23, 42].filter &#123; $0 % 2 == 0 &#125;</span><br><span class="line">// [4, 8, 16, 42]</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">var evenNumbers: [Int] = []</span><br><span class="line">for integer in [4, 8, 15, 16, 23, 42] &#123;</span><br><span class="line">    if integer % 2 == 0 &#123;</span><br><span class="line">        evenNumbers.append(integer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>3.1.3 如果常量或变量的类型可以被推导，则不去主动声明它的类型</p>
</li>
<li><p>3.1.4 如果一个方法返回多个值，那么推荐使用<code>inout</code>修饰的元组类型作为返回值类型 （如果类型不够一目了然，最好使用命名元组来表明你要返回的内容） 。 如果你会多次使用到某个特定的元组，那么可以考虑使用 <code>typealias</code> 。 如果你的元组里返回了 3 个及以上的元素，那么使用 <code>struct </code>或者<code>class</code>可能比元组更合适。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func pirateName() -&gt; (firstName: String, lastName: String) &#123;</span><br><span class="line">    return (&quot;Guybrush&quot;, &quot;Threepwood&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let name = pirateName()</span><br><span class="line">let firstName = name.firstName</span><br><span class="line">let lastName = name.lastName</span><br></pre></td></tr></table></figure></li>
<li><p>3.1.5 在为类声明代理或者协议的时候，要注意循环引用，通常这些属性在声明时要用 weak 修饰。</p>
</li>
<li><p>3.1.6 在逃逸闭包中直接调用 self 的时候，要注意是否会引起循环引用。 - 当可能发生循环引用时尝试使用 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/swift/conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-XID_163">capture list</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">myFunctionWithEscapingClosure() &#123; [weak self] (error) -&gt; Void in</span><br><span class="line">    // 你可以这么做</span><br><span class="line"></span><br><span class="line">    self?.doSomething()</span><br><span class="line"></span><br><span class="line">    // 你也可以这么做</span><br><span class="line"></span><br><span class="line">    guard let strongSelf = self else &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    strongSelf.doSomething()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>3.1.7 不要使用 labeled breaks</p>
</li>
<li><p>3.1.8 流程控制语句的条件语句不需要加括弧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">if x == y &#123;</span><br><span class="line">    /* ... */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">if (x == y) &#123;</span><br><span class="line">    /* ... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>3.1.9 可以使用点语法直接写出枚举值，前面不需要写出枚举类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">imageView.setImageWithURL(url, type: .person)</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">imageView.setImageWithURL(url, type: AsyncImageView.Type.person)</span><br></pre></td></tr></table></figure></li>
<li><p>3.1.10 在声明类方法的时候不要使用缩写，因为和 enum 相比，推导类的上下文会更难</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">imageView.backgroundColor = UIColor.white</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">imageView.backgroundColor = .white</span><br></pre></td></tr></table></figure></li>
<li><p>3.1.11 除非必要，否则尽量不使用<code>self.</code></p>
</li>
<li><p>3.1.12 写方法时，要考虑这个方法是否会被重载。如果不会，标记为<code> final</code>，但请记住，这是为了防止以测试为目的而重载方法。通常，<code>final</code>方法会将编译时间缩短，所以适时使用它是非常棒的。 但是，在库中应用 <code>final </code>关键词要非常小心。因为相对于在本地项目中将某些内容改为非 <code>final</code> ，在库中将某些内容改为非 <code>final </code>可不是小事</p>
</li>
<li><p>3.1.13 使用诸如 <code>else</code> 、<code> catch</code> 等后面跟随代码块的语句，将关键字 和代码块放在同一行。强调一下，我们遵循 <code>1TBS </code>风格 。<code>if / else </code>和<code> do / catch</code> 的示例如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if someBoolean &#123;</span><br><span class="line">    // 做某些事</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 做另一些事</span><br><span class="line">&#125;</span><br><span class="line">do &#123;</span><br><span class="line">    let fileContents = try readFile(&quot;filename.txt&quot;)</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    print(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3.1.14 在定义与类相关的函数或属性而不是定义类的实例变量时时，推荐<code>static</code>，而不是 <code>class</code>。如果你特别需要在子类中重载这个函数的功能时，请使用<code>class</code>。但是，你应该考虑使用<code>protocol</code>来达到这个目的</li>
</ul>
</li>
<li><p>3.1.15 如果有一个函数是无参数的、无副作用的而且返回某个对象或值，更推荐使用计算属性来代替它</p>
</li>
</ul>
<h5 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h5><ul>
<li>3.2.1 如果需要写访问修饰符关键字的话，请将它写在开头<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">private static let myPrivateNumber: Int</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">static private let myPrivateNumber: Int</span><br></pre></td></tr></table></figure></li>
<li>3.2.2 访问修饰符关键字不应该独占一行，而是将它和其描述的东西放在一行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">open class Pirate &#123;</span><br><span class="line">    /* ... */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">open</span><br><span class="line">class Pirate &#123;</span><br><span class="line">    /* ... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>3.2.3 通常情况下，访问修饰符关键字默认是 internal ，所以不用写出来</li>
<li>3.2.4 如果属性需要被单元测试访问，则需要将它标记为 internal ，以便于使用 @testable import ModuleName 。如果属性 应该 是私有的，但是出于单元测试的目的将它声明为 internal，一定要添加适当的文档注释来解释这一点。 为了更加简明，你可以使用 - warning: 标记语法，如下所示<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 这个属性定义海盗的名字。</span><br><span class="line"> - warning: 不要为 `@testable` 添加 `private` 访问修饰符 </span><br><span class="line"> */</span><br><span class="line">let pirateName = &quot;LeChuck&quot;</span><br></pre></td></tr></table></figure></li>
<li>3.2.5 尽可能使用<code> private</code> 而不是<code> fileprivate</code></li>
<li>3.2.6 当在<code>public</code>和 <code>open </code>两者之间选择一个时，如果你打算让某些内容在模块外也可以被继承，推荐使用<code>open</code>，否则请使用 <code>public</code>。注意，任何 <code>internal </code>或更高访问权限的内容，都可以通过使用 <code>@testable import</code> 在测试中被继承。所以这不应该成为使用 <code>open</code> 的理由。通常，在涉及到库的时候，更倾向于自由地使用<code>open</code>。但是， <code>open </code>可以轻易地同时改变应用程序中多个模块的内容。当涉及到这类代码库中的模块时，更倾向于保守地使用 <code>open </code></li>
</ul>
<h5 id="自定义运算符"><a href="#自定义运算符" class="headerlink" title="自定义运算符"></a>自定义运算符</h5><p>推荐创建自定义运算符。<br>如果要引入自定义运算符，确保你有一个很好的理由，为什么你想把一个新的运算符引入全局范围，而不是使用其他现有的运算符。<br>可以重写现有的运算符以支持新类型 (特别是 &#x3D;&#x3D; ) 然而，你新定义的必须保存运算符的语义。例如， &#x3D;&#x3D; 必须是检测是否相等并返回检测结果的布尔值</p>
<h5 id="Switch-语句和枚举"><a href="#Switch-语句和枚举" class="headerlink" title="Switch 语句和枚举"></a>Switch 语句和枚举</h5><ul>
<li>3.4.1 当使用具有有限可能性的 <code>switch </code>语句 <code>( enum )</code>，不包括 <code>default </code>的其他情况。将未处理的情况放置在 <code>default </code>里，并使用 break 来结束执行</li>
<li>3.4.2 在 Swift 中由于 <code>switch </code>的各种情况中默认有<code>break</code>，如果不需要，可以省略<code>break</code>关键字</li>
<li>3.4.3 <code>case </code>和 <code>switch </code>的声明要按照 Swift 的规范独占一行</li>
<li>3.4.4 当定义具有关联值的情况时，确保这个值被适当的标记，例如：<code>case hunger(hungerLevel: Int) </code>而不是<code>case hunger(Int)</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">enum Problem &#123;</span><br><span class="line">    case attitude</span><br><span class="line">    case hair</span><br><span class="line">    case hunger(hungerLevel: Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func handleProblem(problem: Problem) &#123;</span><br><span class="line">    switch problem &#123;</span><br><span class="line">    case .attitude:</span><br><span class="line">        print(&quot;At least I don&#x27;t have a hair problem.&quot;)</span><br><span class="line">    case .hair:</span><br><span class="line">        print(&quot;Your barber didn&#x27;t know when to stop.&quot;)</span><br><span class="line">    case .hunger(let hungerLevel):</span><br><span class="line">        print(&quot;The hunger level is \(hungerLevel).&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>3.4.5 更推荐使用<code>fallthrough</code>关键字来处理一系列的<code> cases （例如: case 1, 2, 3: ）</code></li>
<li>3.4.6 如果您有一个不应该达到的默认情况，最好抛出一个错误（或处理其他类似的方法，如断言<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func handleDigit(_ digit: Int) throws &#123;</span><br><span class="line">    switch digit &#123;</span><br><span class="line">    case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9:</span><br><span class="line">        print(&quot;Yes, \(digit) is a digit!&quot;)</span><br><span class="line">    default:</span><br><span class="line">        throw Error(message: &quot;The given number was not a digit.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h5><ul>
<li>3.5.1 使用隐式解包可选类型的唯一机会是使用 <code>@IBOutlet</code> 的时候。在其他情况下，使用非可选或常规可选的属性会更好。是的，有某些情况下，你可以「保证」使用时属性不会为 nil ，但是安全和一致会更好。同样，不要使用强制解包</li>
<li>3.5.2 不要使用 <code>as! </code>或 <code>try!</code></li>
<li>3.5.3 如果你不打算真正地使用存在可选类型中的值，但需要判断这个值是否为 <code>nil </code>，显式地检查这个值是不是<code> nil</code> ，而不是使用 <code>if let </code>语法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">if someOptional != nil &#123;</span><br><span class="line">    // 做某件事</span><br><span class="line">&#125;</span><br><span class="line">// 不推荐</span><br><span class="line">if let _ = someOptional &#123;</span><br><span class="line">    // 做某件事</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>3.5.4 不要使用 <code>unowned </code>你可以将<code>unowned</code>视为被隐式解包的 <code>weak </code>属性的等价物（虽然 <code>unowned </code>因为完全忽略引用计数而略有性能上的提升）。因为我们不想有隐式解包，所以我们同样也不想要 <code>unowned </code>属性<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">weak var parentViewController: UIViewController?</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">weak var parentViewController: UIViewController!</span><br><span class="line">unowned var parentViewController: UIViewController</span><br></pre></td></tr></table></figure></li>
<li>3.5.5 在解包可选类型时，在恰当的地方使用相同名称来命名解包的常量或变量<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">guard let myValue = myValue else &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="3-6-协议"><a href="#3-6-协议" class="headerlink" title="3.6 协议"></a>3.6 协议</h5><p>在实现协议时，有两种方式组织代码：</p>
<p>1、使用 <code>// MARK: </code>注释将协议实现和其他部分的代码隔开。<br>2、在同一资源文件中 <code>class/struct </code>实现代码以外的地方，使用扩展。</p>
<p>记住使用扩展时，无论怎样，扩展中的方法不要被子类重载，这会使测试变麻烦。如果这是一个通用的使用场景，为了一致性使用方法 <code>1 </code>可能会更好。否则，<code>2 </code>可以使关系的拆分更清楚。<br>即使使用方法<code> 2</code> ，也要添加<code>// MARK:</code>语句，以便在 <code>Xcode </code>的方法 &#x2F; 属性 &#x2F; 类等的列表 UI 中更加易读</p>
<h5 id="3-7-属性"><a href="#3-7-属性" class="headerlink" title="3.7 属性"></a>3.7 属性</h5><ul>
<li>3.7.1 如果创建只读的计算属性，提供不带 get {} 的获取方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var computedProperty: String &#123;</span><br><span class="line">    if someBool &#123;</span><br><span class="line">        return &quot;I&#x27;m a mighty pirate!&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;I&#x27;m selling these fine leather jackets.&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>3.7.2 使用 <code>get &#123;&#125; </code>、 <code>set &#123;&#125; </code>、 <code>willSet</code> 和<code>didSet</code>时，缩进这些块</li>
<li>3.7.3 虽然你可以为 <code>willSet/didSet </code>和<code>set</code>自定义新值或旧值的名称，但请使用默认提供的标准标识符 <code>newValue / oldValue </code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var storedProperty: String = &quot;I&#x27;m selling these fine leather jackets.&quot; &#123;</span><br><span class="line">    willSet &#123;</span><br><span class="line">        print(&quot;will set to \(newValue)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    didSet &#123;</span><br><span class="line">        print(&quot;did set from \(oldValue) to \(storedProperty)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var computedProperty: String  &#123;</span><br><span class="line">    get &#123;</span><br><span class="line">        if someBool &#123;</span><br><span class="line">            return &quot;I&#x27;m a mighty pirate!&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        return storedProperty</span><br><span class="line">    &#125;</span><br><span class="line">    set &#123;</span><br><span class="line">        storedProperty = newValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>3.7.4 你可以按如下方式声明一个单例属性：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class PirateManager &#123;</span><br><span class="line">    static let shared = PirateManager()</span><br><span class="line"></span><br><span class="line">    /* ... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="3-8-闭包"><a href="#3-8-闭包" class="headerlink" title="3.8 闭包"></a>3.8 闭包</h5><ul>
<li>3.8.1 如果可以明确参数类型，即可以省略参数类型也可以显示参数类型。你可以根据场景决定是否添加一些说明来提高代码的可读性，或者是省略一些无关紧要的部分<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 省略参数类型</span><br><span class="line">doSomethingWithClosure() &#123; response in</span><br><span class="line">    print(response)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 明确参数类型</span><br><span class="line">doSomethingWithClosure() &#123; response: NSURLResponse in</span><br><span class="line">    print(response)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 参数名缩写</span><br><span class="line">[1, 2, 3].flatMap &#123; String($0) &#125;</span><br></pre></td></tr></table></figure></li>
<li>3.8.2 声明了一个闭包，不需要用括号括起来，除非需要（例如，闭包类型是可选的，或者这个闭包在另一个闭包内）。闭包的参数都是是放在圆括号里，如果用 <code>() </code>就表示没有参数，用<code>Void</code>表示无返回值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let completionBlock: (Bool) -&gt; Void = &#123; (success) in</span><br><span class="line">    print(&quot;Success? \(success)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let completionBlock: () -&gt; Void = &#123;</span><br><span class="line">    print(&quot;Completed!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let completionBlock: (() -&gt; Void)? = nil</span><br></pre></td></tr></table></figure></li>
<li>3.8.3 在闭包中尽可能的让参数保持在同一行，避免过多换行。（确保每行小于 160 个字符)</li>
<li>3.8.4 如果闭包的含义不太明确可以使用尾随闭包（如果一个方法同时含有成功和失败的两个闭包就不建议使用尾随闭包）。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 尾随闭包</span><br><span class="line">doSomething(1.0) &#123; (parameter1) in</span><br><span class="line">    print(&quot;Parameter 1 is \(parameter1)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 无尾随闭包</span><br><span class="line">doSomething(1.0, success: &#123; (parameter1) in</span><br><span class="line">    print(&quot;Success with \(parameter1)&quot;)</span><br><span class="line">&#125;, failure: &#123; (parameter1) in</span><br><span class="line">    print(&quot;Failure with \(parameter1)&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="3-9-数组"><a href="#3-9-数组" class="headerlink" title="3.9 数组"></a>3.9 数组</h5><ul>
<li>3.9.1 通常要避免直接用下标的方式访问数组。尽可能使用访问器，比如<code> .first</code> 或<code> .last</code>。它们是可选类型并且不会导致崩溃。推荐尽可能地使用 <code>for item in items </code>语法而不是类似与 <code>for i in 0 ..&lt; items.count </code>的语法。如果你需要直接用下标访问数组，一定要做适当的边界检查。你可以使用<code>for (index, value) in items.enumerated()</code>来一并得到索引和值</li>
<li>3.9.2 不要使用 <code>+=</code> 或<code>+</code>操作符来追加或串联到数组。而是使用 <code>.append() </code>或<code> .append(contentsOf:)</code>，因为在 Swift 当前的状况下它们（至少在编译方面）拥有更高的性能。如果基于其他数组声明数组而且想让它保持不变，使用<code> let myNewArray = [arr1, arr2].joined()</code>，而不是<code> let myNewArray = arr1 + arr2</code></li>
</ul>
<h5 id="3-10-错误处理"><a href="#3-10-错误处理" class="headerlink" title="3.10 错误处理"></a>3.10 错误处理</h5><p>假设函数 myFunction 应该返回 String，但是，某些时候它会运行错误。在出错时返回 nil 的情况下，通用的处理方式是让函数返回可选类型 String?。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func readFile(named filename: String) -&gt; String? &#123;</span><br><span class="line">    guard let file = openFile(named: filename) else &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let fileContents = file.read()</span><br><span class="line">    file.close()</span><br><span class="line">    return fileContents</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func printSomeFile() &#123;</span><br><span class="line">    let filename = &quot;somefile.txt&quot;</span><br><span class="line">    guard let fileContents = readFile(named: filename) else &#123;</span><br><span class="line">        print(&quot;Unable to open file \(filename).&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    print(fileContents)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相反，在适当的时候，我们应该使用 Swift 的 <code>try/catch </code>操作来了解失败原因。</p>
<p>你可以使用<code> struct</code>，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct Error: Swift.Error &#123;</span><br><span class="line">    public let file: StaticString</span><br><span class="line">    public let function: StaticString</span><br><span class="line">    public let line: UInt</span><br><span class="line">    public let message: String</span><br><span class="line"></span><br><span class="line">    public init(message: String, file: StaticString = #file, function: StaticString = #function, line: UInt = #line) &#123;</span><br><span class="line">        self.file = file</span><br><span class="line">        self.function = function</span><br><span class="line">        self.line = line</span><br><span class="line">        self.message = message</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用法示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func readFile(named filename: String) throws -&gt; String &#123;</span><br><span class="line">    guard let file = openFile(named: filename) else &#123;</span><br><span class="line">        throw Error(message: &quot;Unable to open file named \(filename).&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let fileContents = file.read()</span><br><span class="line">    file.close()</span><br><span class="line">    return fileContents</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func printSomeFile() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        let fileContents = try readFile(named: filename)</span><br><span class="line">        print(fileContents)</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">        print(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一些例外情况，使用可选类型比使用错误处理更有意义。当返回结果语义上可能是<code> nil</code>，而不是取回结果时的错误值时，返回可选类型比使用错误处理更有意义。</p>
<p>通常，如果方法可能「失败」，并且返回值为可选类型，失败的原因就不是很明显了，那么方法抛出错误可能会更有意义。</p>
<h5 id="3-11-使用-guard-语句"><a href="#3-11-使用-guard-语句" class="headerlink" title="3.11 使用 guard 语句"></a>3.11 使用<code> guard</code> 语句</h5><ul>
<li>3.11.1 一般情况下，我们推荐在适用的地方使用「尽早返回」的策略 而不是在 if 语句里嵌套代码。在这种使用场景下，使用 guard 语句通常很有用，而且可以提升代码的可读性。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">func eatDoughnut(at index: Int) &#123;</span><br><span class="line">    guard index &gt;= 0 &amp;&amp; index &lt; doughnuts.count else &#123;</span><br><span class="line">        // 尽早返回因为索引越界了</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let doughnut = doughnuts[index]</span><br><span class="line">    eat(doughnut)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">func eatDoughnut(at index: Int) &#123;</span><br><span class="line">    if index &gt;= 0 &amp;&amp; index &lt; doughnuts.count &#123;</span><br><span class="line">        let doughnut = doughnuts[index]</span><br><span class="line">        eat(doughnut)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>3.11.2 当解包可选类型时，推荐 guard 语句而不是 if 语句来减少代码中嵌套缩进的数量<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">guard let monkeyIsland = monkeyIsland else &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">bookVacation(on: monkeyIsland)</span><br><span class="line">bragAboutVacation(at: monkeyIsland)</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">if let monkeyIsland = monkeyIsland &#123;</span><br><span class="line">    bookVacation(on: monkeyIsland)</span><br><span class="line">    bragAboutVacation(at: monkeyIsland)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 甚至更不推荐</span><br><span class="line">if monkeyIsland == nil &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">bookVacation(on: monkeyIsland!)</span><br><span class="line">bragAboutVacation(at: monkeyIsland!)</span><br></pre></td></tr></table></figure></li>
<li>3.11.3 在解包类型不复杂，需要在使用 <code>if </code>还是 <code>guard </code>之间做抉择时，要记住最重要的是代码的可读性。会有很多可能的情况，例如依赖于两个不同的布尔值、复杂逻辑语句涉及到多个判断等，所以通常使用您的最佳的判断来写出可读且一致的代码。如果你不确定 <code>guard </code>或 <code>if </code>哪个更具可读性或者它们看起来同样可读，推荐使用 <code>guard</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 这里 `if` 语句的可读性很高</span><br><span class="line">if operationFailed &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这里 `guard` 语句的可读性很高</span><br><span class="line">guard isSuccessful else &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 像这种双重否定逻辑很难读懂—即不要这样做</span><br><span class="line">guard !operationFailed else &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>3.11.4 如果在两种语句之间做选择，使用 <code>if </code>语句比使用 <code>guard </code>语句更有意义<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">if isFriendly &#123;</span><br><span class="line">    print(&quot;Hello, nice to meet you!&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    print(&quot;You have the manners of a beggar.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">guard isFriendly else &#123;</span><br><span class="line">    print(&quot;You have the manners of a beggar.&quot;)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&quot;Hello, nice to meet you!&quot;)</span><br></pre></td></tr></table></figure></li>
<li>3.11.5 只有在失败会导致退出当前上下文的情况下，才应该使用 <code>guard</code>。 下面是一个例子，在其中使用两个 if 语句而不是使用两个 <code>guard</code> 语句更有意义 — 有两个不相互阻塞的无关条件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if let monkeyIsland = monkeyIsland &#123;</span><br><span class="line">    bookVacation(onIsland: monkeyIsland)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if let woodchuck = woodchuck, canChuckWood(woodchuck) &#123;</span><br><span class="line">    woodchuck.chuckWood()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>3.11.6 通常，我们可能遇到需要使用 guard 语句解包多个可选类型的情况。一般情况下，如果处理每个解包的失败是相同的（例如，<code>return</code>、<code>break</code>、<code>continue</code>、<code>throw </code>或一些其他的 <code>@noescape</code>），将解包合入一个 <code>guard </code>语句<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 因为只是返回，所以合并为一个。</span><br><span class="line">guard let thingOne = thingOne,</span><br><span class="line">    let thingTwo = thingTwo,</span><br><span class="line">    let thingThree = thingThree else &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 因为在每种情况下处理特定的错误，所以拆分成单独的语句。</span><br><span class="line">guard let thingOne = thingOne else &#123;</span><br><span class="line">    throw Error(message: &quot;Unwrapping thingOne failed.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">guard let thingTwo = thingTwo else &#123;</span><br><span class="line">    throw Error(message: &quot;Unwrapping thingTwo failed.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">guard let thingThree = thingThree else &#123;</span><br><span class="line">    throw Error(message: &quot;Unwrapping thingThree failed.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>3.11.7 不要将 guard 语句写成只有一行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">guard let thingOne = thingOne else &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">guard let thingOne = thingOne else &#123; return &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Part-04-文档-x2F-注释"><a href="#Part-04-文档-x2F-注释" class="headerlink" title="Part-04: 文档 &#x2F; 注释"></a>Part-04: 文档 &#x2F; 注释</h4><h5 id="4-1-文档"><a href="#4-1-文档" class="headerlink" title="4.1 文档"></a>4.1 文档</h5><p>如果函数比简单的 O (1) 操作负责，通常应该考虑为函数加个文档。因为方法签名的一些信息可能不是那么明显。如果实现方式有任何怪癖，无论在技术上有趣、棘手、不明显等等，都应该被文档化。应该为复杂的类 &#x2F; 结构体 &#x2F; 枚举 &#x2F; 协议和属性添加文档。所有的<code> public</code> <code>函数 / 类 / 属性 / 常量 / 结构体 / 枚举 / 协议</code>等也应该被文档化。（如果，他们的签名 &#x2F; 名称不能使他们含义 &#x2F; 功能很明显）。</p>
<p>写完文档注释之后，你应该按住<code> option</code> 键并单击函数 &#x2F; 属性 &#x2F; 类等等来确认文档注释被正确地格式化了。</p>
<p>务必查看 Swift 注释标记中提供的全套功能，详见 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/tvos/documentation/Xcode/Reference/xcode_markup_formatting_ref/Attention.html#//apple_ref/doc/uid/TP40016497-CH29-SW1">Apple 的文档</a></p>
<p>原则:</p>
<ul>
<li>4.1.1 160 个字符列的限制（和代码的部分一样</li>
<li>4.1.2 如果文档注释在一行内，使用（ <code>/** */ </code>）</li>
<li>4.1.3 不要在每一个附加行前面加<code> *</code></li>
<li>4.1.4 使用新的 <code>- parameter </code>语法而不是旧的 <code>:param: </code>语法（务必使用小写的 <code>parameter </code>而并不是 <code>Parameter </code>）。 按住 <code>Option </code>键并单击你写的方法以确保快速帮助看起来是正确的<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Human &#123;</span><br><span class="line">    /**</span><br><span class="line">     这个方法向某人喂某种事物。</span><br><span class="line"></span><br><span class="line">     - parameter food: 你想被他吃的食物</span><br><span class="line">     - parameter person: 应该吃食物的人</span><br><span class="line">     - returns: 如果食物被那个人吃了，为 True；否则为 false。 </span><br><span class="line">    */</span><br><span class="line">    func feed(_ food: Food, to person: Human) -&gt; Bool &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>4.1.5 如果你要给方法的参数 &#x2F; 返回值 &#x2F; 抛出的异常写文档，即使某些文档最终会有重复，也请将它们都写入文档（这比文档看起来不完整更可取）。有时，如果仅有一个参数需要写文档，在描述中提及它更好一些</li>
<li>4.1.6 对于复杂的类，请使用一些看起来合适的示例来描述类的用法。记住在 <code>Swift </code>注释文档中可以使用 <code>markdown </code>语法。因此，换行符、列表等等都是适用的<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> ## 功能支持</span><br><span class="line"></span><br><span class="line"> 这个类做了一些很棒的事情。它支持：</span><br><span class="line"></span><br><span class="line"> - 功能 1</span><br><span class="line"> - 功能 2</span><br><span class="line"> - 功能 3</span><br><span class="line"></span><br><span class="line"> ## 示例</span><br><span class="line"></span><br><span class="line"> 这有一个用例，由于它表示一个代码块，所以使用四个空格缩进：</span><br><span class="line"></span><br><span class="line">     let myAwesomeThing = MyAwesomeClass()</span><br><span class="line">     myAwesomeThing.makeMoney()</span><br><span class="line"></span><br><span class="line"> ## 警告</span><br><span class="line"></span><br><span class="line"> 有一些你需要注意的事项：</span><br><span class="line"></span><br><span class="line"> 1. 事项一</span><br><span class="line"> 2. 事项二</span><br><span class="line"> 3. 事项三</span><br><span class="line"> */</span><br><span class="line">class MyAwesomeClass &#123;</span><br><span class="line">    /* ... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>4.1.7 提及代码时，请使用代码提示<code>-</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 或许这里使用 `UIViewController` 做了某事</span><br><span class="line"> - warning: 在运行这个函数之前，请确保 `someValue` 为 `true`。</span><br><span class="line"> */</span><br><span class="line">func myFunction() &#123;</span><br><span class="line">    /* ... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>4.1.8 写文档注释时，尽可能保持简洁</li>
</ul>
<h5 id="4-2-其他注释原则"><a href="#4-2-其他注释原则" class="headerlink" title="4.2 其他注释原则"></a>4.2 其他注释原则</h5><ul>
<li>4.2.1 始终在<code>//</code>后面加个空格</li>
<li>4.2.2 始终在自己的行中写注释</li>
<li>4.2.3 使用 <code>// MARK: - </code>无论是什么 时，在注释后加个空行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Pirate &#123;</span><br><span class="line"></span><br><span class="line">    // MARK: - 实例属性</span><br><span class="line"></span><br><span class="line">    private let pirateName: String</span><br><span class="line"></span><br><span class="line">    // MARK: - 构造函数</span><br><span class="line"></span><br><span class="line">    init() &#123;</span><br><span class="line">        /* ... */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Part-05-转载"><a href="#Part-05-转载" class="headerlink" title="Part-05:转载"></a>Part-05:转载</h4><p><a target="_blank" rel="noopener" href="https://github.com/linkedin/swift-style-guide/">原文地址</a><br><a target="_blank" rel="noopener" href="https://learnku.com/ios/t/23230/linkedin-official-swift-style-guide">译文地址</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://iamlay.com/2020/08/28/week2020-36/" data-id="clfj8cp2y002kfbf34une2msx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOSCodeSpecification" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/26/iOSCodeSpecification/" class="article-date">
  <time datetime="2020-08-26T04:59:15.000Z" itemprop="datePublished">2020-08-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/26/iOSCodeSpecification/">iOS代码规范 - OC版</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Part1-1：-Objective-C命名规范"><a href="#Part1-1：-Objective-C命名规范" class="headerlink" title="Part1-1： Objective-C命名规范"></a>Part1-1： Objective-C命名规范</h4><h5 id="一般性原则"><a href="#一般性原则" class="headerlink" title="一般性原则"></a>一般性原则</h5><ul>
<li>遵循大部分开发语言的一般性命名原则。</li>
<li>方法名不要使用 new 作为前缀。</li>
<li>驼峰命名规则，第一个单词的首字符小写。</li>
<li>一般方法不使用前缀命名。</li>
<li>私有方法可以使用统一的前缀来分组和辨识。</li>
<li>表示对象行为的方法,名称以动词开头。</li>
</ul>
<p>以动词开头的方法命名,标识对象的行为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void) selectTabViewItem:(NSTableViewItem *)tableViewItem</span><br></pre></td></tr></table></figure>
<blockquote>
<p>名称中不要出现<br>do或does,因为这些助动词没什么实际意义。也不要在动词前使用副词或形容词修饰。</p>
</blockquote>
<ul>
<li>如果方法返回方法接收者的某个属性,直接用属性名称命名。不要使用 get，除非是间接返回一个或多个值。</li>
</ul>
<p>推荐</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSSize) cellSize;</span><br></pre></td></tr></table></figure>
<p>反对</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSSize) getCellSize;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数要用描述该参数的关键字命名</li>
</ul>
<p>推荐</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void) sendAction:(SEL)aSelector to:(id)anObject forAllCells:(BOOL)flag;</span><br></pre></td></tr></table></figure>
<p>反对</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void) sendAction:(SEL)aSelector  :(id)anObject  :(BOOL)flag;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数前面的单词要能描述该参数</li>
</ul>
<p>推荐</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id) viewWithTag:(int)aTag;</span><br></pre></td></tr></table></figure>

<p>反对</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id) taggedView:(int)aTag;</span><br></pre></td></tr></table></figure>
<ul>
<li>细化基类中的已有方法:创建一个新方法,其名称是在被细化方法名称后面追加参数关键词</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithFrame:(CGRect)frameRect;//NSView, UIView.</span><br><span class="line">- (id)initWithFrame:(NSRect)frameRect mode:(int)aMode  cellClass:(Class)factoryId numberOfRows:(int)rowsHigh numberOfColumns (int)colsWide;//NSMatrix, a subclass of NSView</span><br></pre></td></tr></table></figure>
<ul>
<li>不要使用 and 来连接用属性作参数的关键字</li>
</ul>
<p>推荐</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (int)runModalForDirectory:(NSString *)path file:(NSString *)name types:(NSArray *)fileTypes;</span><br></pre></td></tr></table></figure>
<p>反对</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (int)runModalForDirectory:(NSString *)path andFile:(NSString *)name andTypes:(NSArray *)fileTypes;</span><br></pre></td></tr></table></figure>
<p>虽然上面的例子中使用 add 看起来也不错,但当你方法有太多参数关键字时就有问题。</p>
<ul>
<li>如果方法描述两种独立的行为,使用 and 来串接它们</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL) openFile:(NSString *)fullPath withApplication:(NSString NSWorkspace *)appName andDeactivate:(BOOL)flag;//NSWorkspace.</span><br></pre></td></tr></table></figure>

<h5 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h5><blockquote>
<p>访问方法是对象属性的读取与设置方法。其命名有特定的格式依赖于属性的描述内容。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void) setNoun:(type)aNoun;</span><br><span class="line">- (type) noun;</span><br></pre></td></tr></table></figure>

<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void) setgColor:(NSColor *)aColor;</span><br><span class="line">- (NSColor *) color;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果属性是用形容词描述的,则命名格式为:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void) setAdjective:(BOOL)flag;</span><br><span class="line">- (BOOL) isAdjective;</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void) setEditable:(BOOL)flag;</span><br><span class="line">- (BOOL) isEditable;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果属性是用动词描述的,则命名格式为:(动词要用现在时时态)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void) setVerbObject:(BOOL)flag;</span><br><span class="line">- (BOOL) verbObject;</span><br></pre></td></tr></table></figure>
例如:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void) setShowAlpha:(BOOL)flag;</span><br><span class="line">- (BOOL) showsAlpha;</span><br></pre></td></tr></table></figure>

<ul>
<li>不要使用动词的过去分词形式作形容词使用</li>
</ul>
<p>推荐</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)setAcceptsGlyphInfo:(BOOL)flag;</span><br><span class="line">- (BOOL)acceptsGlyphInfo;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>反对</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)setGlyphInfoAccepted:(BOOL)flag;</span><br><span class="line">- (BOOL)glyphInfoAccepted;    </span><br></pre></td></tr></table></figure>
<ul>
<li>可以使用情态动词(can, should, will 等)来提高清晰性,但不要使用 do 或 does</li>
</ul>
<p>推荐</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void) setCanHide:(BOOL)flag;             </span><br><span class="line">- (BOOL) canHide;</span><br></pre></td></tr></table></figure>
<p>反对</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void) setDoseAcceptGlyphInfo:(BOOL)flag;</span><br><span class="line">- (BOOL) doseAcceptGlyphInfo;</span><br></pre></td></tr></table></figure>
<ul>
<li>只有在方法需要间接返回多个值的情况下,才使用 get</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void) getLineDash:(float *)pattern count:(int *)count phase:(float *)phase;</span><br></pre></td></tr></table></figure>

<p>像上面这样的方法,在其实现里应允许接受 NULL 作为其 in&#x2F;out 参数,以表示调用者对一个或多个返回 值不感兴趣。</p>
<p><strong>委托方法:</strong> 委托方法是那些在特定事件发生时可被对象调用,并声明在对象的委托类中的方法。它们有独特的命名约 定,这些命名约定同样也适用于对象的数据源方法。</p>
<ul>
<li>名称以标示发送消息的对象的类名开头,省略类名的前缀并小写类第一个字符</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL) tableView:(NSTableView *)tableView shouldSelectRow:(int)row;</span><br><span class="line">- (BOOL)application:(NSApplication *)sender openFile:(NSString *)filename;</span><br></pre></td></tr></table></figure>

<ul>
<li>冒号紧跟在类名之后(随后的那个参数表示委派的对象)。该规则不适用于只有一个 sender 参数的方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL) applicationOpenUntitledFile:(NSApplication *)sender;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的那条规则也不适用于响应通知的方法。在这种情况下,方法的唯一参数表示通知对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void) windowDidChangeScreen:(NSNotification *)notification;</span><br></pre></td></tr></table></figure>

<ul>
<li>用于通知委托对象操作即将发生或已经发生的方法名中要使用 did 或 will</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void) browserDidScroll:(NSBrowser *)sender;</span><br><span class="line">- (NSUndoManager *) windowWillReturnUndoManager:(NSWindow *)window;</span><br></pre></td></tr></table></figure>

<p>用于询问委托对象可否执行某操作的方法名中可使用 did 或 will,但最好使用 should</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL) windowShouldClose:(id)sender;</span><br></pre></td></tr></table></figure>

<h5 id="集合方法"><a href="#集合方法" class="headerlink" title="集合方法"></a>集合方法</h5><p>管理对象(集合中的对象被称之为元素)的集合类,约定要具备如下形式的方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void) addElement:(elementType)adObj;</span><br><span class="line">- (void) removeElement:(elementType)anObj;</span><br><span class="line">- (NSArray *)elements;</span><br></pre></td></tr></table></figure>

<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void) addLayoutManager:(NSLayoutManager *)adObj;</span><br><span class="line">- (void) removeLayoutManager:(NSLayoutManager *)anObj;</span><br><span class="line">- (NSArray *)layoutManagers;</span><br></pre></td></tr></table></figure>

<p>集合方法命名有如下一些限制和约定:</p>
<ul>
<li>如果集合中的元素无序,返回 NSSet,而不是 NSArray</li>
<li>如果将元素插入指定位置的功能很重要,则需具备如下方法:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void) insertElement:(elementType)anObj atIndex:(int)index;</span><br><span class="line">- (void) removeElementAtIndex:(int)index;</span><br></pre></td></tr></table></figure>

<p>集合方法的实现要考虑如下细节:</p>
<ul>
<li>以上集合类方法通常负责管理元素的所有者关系,在 add 或 insert 的实现代码里会 retain 元素,在 remove 的实现代码中会 release 元素</li>
<li>当被插入的对象需要持有指向集合对象的指针时,通常使用 set… 来命名其设置该指针的方法,且不 要 retain 集合对象。比如上面的 insertLayerManager:atIndex: 这种情形,NSLayoutManager 类使 用如下方法:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void) setTextStorage:(NSTextStorage *)textStorage;</span><br><span class="line">- (NSTextStorage *)textStorage;</span><br></pre></td></tr></table></figure>

<p>通常你不会直接调用 setTextStorage:,而是覆写它。<br>另一个关于集合约定的例子来自 NSWindow 类:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void) addChildWindow:(NSWindow *)childWin ordered:(NSWindowOrderingMode)place;</span><br><span class="line">- (void) removeChildWindow:(NSWindow *)childWin;</span><br><span class="line">- (NSArray *)childWindows;</span><br><span class="line">- (NSWindow *) parentWindow;</span><br><span class="line">- (void) setParentWindow:(NSWindow *)window;</span><br></pre></td></tr></table></figure>

<h5 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h5><p>命名方法参数时要考虑如下规则:</p>
<ul>
<li>如同方法名,参数名小写第一个单词的首字符,大写后继单词的首字符。如:removeObject:(id)anObject</li>
<li>不要在参数名中使用 pointer 或 ptr,让参数的类型来说明它是指针</li>
<li>避免使用 one, two,…,作为参数名</li>
<li>避免为节省几个字符而缩写</li>
</ul>
<p>照 Cocoa 惯例,以下关键字与参数联合使用:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...action:(SEL)aSelector</span><br><span class="line">..alignment:(int)mode</span><br><span class="line">...atIndex:(int)index</span><br><span class="line">...content:(NSRect)aRect</span><br><span class="line">...doubleValue:(double)aDouble</span><br><span class="line">...floatValue:(float)aFloat</span><br><span class="line">...font:(NSFont *)fontObj</span><br><span class="line">...frame:(NSRect)frameRect</span><br><span class="line">...intValue:(int)anInt</span><br><span class="line">...keyEquivalent:(NSString *)charCode</span><br><span class="line">...length:(int)numBytes</span><br><span class="line">...point:(NSPoint)aPoint</span><br><span class="line">...stringValue:(NSString *)aString</span><br><span class="line">...tag:(int)anInt</span><br><span class="line">...target:(id)anObject</span><br><span class="line">...title:(NSString *)aString</span><br></pre></td></tr></table></figure>

<h5 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h5><blockquote>
<p>大多数情况下,私有方法命名相同与公共方法命名约定相同,但通常我们约定给私有方法添加前缀,以便 与公共方法区分开来。即使这样,私有方法的名称很容易导致特别的问题。当你设计一个继承自 Cocoa framework 某个类的子类时,你无法知道你的私有方法是否不小心覆盖了框架中基类的同名方法。</p>
</blockquote>
<p>Cocoa framework 的私有方法名称通常以下划线作为前缀(如:_fooData),以标示其私有属性。基于这 样的事实,遵循以下两条建议:</p>
<ul>
<li>不要使用下划线作为你自己的私有方法名称的前缀,Apple 保留这种用法。</li>
<li>若要继承 Cocoa framework 中一个超大的类(如:NSView),并且想要使你的私有方法名称与基类中的区别开来,你可以为你的私有方法名称添加你自己的前缀。这个前缀应该具有唯一性, 建议用”p_Method”格式，p代表private。</li>
</ul>
<p>尽管为私有方法名称添加前缀的建议与前面类中方法命名的约定冲突,这里的意图有所不同:为了防止不 小心地覆盖基类中的私有方法。</p>
<h4 id="Part1-2：-Objective-C语法规范"><a href="#Part1-2：-Objective-C语法规范" class="headerlink" title="Part1-2： Objective-C语法规范"></a>Part1-2： Objective-C语法规范</h4><h5 id="点语法"><a href="#点语法" class="headerlink" title="点语法"></a>点语法</h5><p>应该 <code>始终</code> 使用点语法来访问或者修改属性，访问其他实例时首选括号。</p>
<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">view.backgroundColor = [UIColor orangeColor];</span><br><span class="line">[UIApplication sharedApplication].delegate;</span><br></pre></td></tr></table></figure>

<p>反对</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[view setBackgroundColor:[UIColor orangeColor]];</span><br><span class="line">UIApplication.sharedApplication.delegate;</span><br></pre></td></tr></table></figure>

<h5 id="间距"><a href="#间距" class="headerlink" title="间距"></a>间距</h5><ul>
<li>一个缩进使用 4 个空格，永远不要使用制表符（tab）缩进。请确保在 Xcode 中设置了此偏好。</li>
<li>方法的大括号和其他的大括号（if&#x2F;else&#x2F;switch&#x2F;while 等等）始终和声明在同一行开始，在新的一行结束。</li>
</ul>
<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if (user.isHappy) &#123;</span><br><span class="line">    // Do something</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    // Do something else</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法之间应该正好空一行，这有助于视觉清晰度和代码组织性。在方法中的功能块之间应该使用空白分开，但往往可能应该创建一个新的方法。</li>
<li><code>@synthesize</code> 和 <code>@dynamic </code>在实现中每个都应该占一个新行。</li>
</ul>
<h5 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h5><p>条件判断主体部分应该始终使用大括号括住来防止出错，即使它可以不用大括号（例如它只需要一行）。这些错误包括添加第二行（代码）并希望它是 if 语句的一部分时。还有另外一种<a target="_blank" rel="noopener" href="http://programmers.stackexchange.com/a/16530">更危险的</a>，当 if 语句里面的一行被注释掉，下一行就会在不经意间成为了这个 if 语句的一部分。此外，这种风格也更符合所有其他的条件判断，因此也更容易检查。</p>
<p>推荐:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!error) &#123;</span><br><span class="line">    return success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (!error)</span><br><span class="line">    return success;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (!error) return success;</span><br></pre></td></tr></table></figure>

<h5 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h5><p>三目运算符，? ，只有当它可以增加代码清晰度或整洁时才使用。单一的条件都应该优先考虑使用。多条件时通常使用 if 语句会更易懂，或者重构为实例变量。</p>
<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = a &gt; b ? x : y;</span><br></pre></td></tr></table></figure>

<p>反对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = a &gt; b ? x = c &gt; d ? c : d : y;</span><br></pre></td></tr></table></figure>

<h5 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h5><p>当引用一个返回错误参数（error parameter）的方法时，应该针对返回值，而非错误变量。</p>
<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSError *error;</span><br><span class="line">if (![self trySomethingWithError:&amp;error]) &#123;</span><br><span class="line">    // 处理错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSError *error;</span><br><span class="line">[self trySomethingWithError:&amp;error];</span><br><span class="line">if (error) &#123;</span><br><span class="line">    // 处理错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一些苹果的 API 在成功的情况下会写一些垃圾值给错误参数（如果非空），所以针对错误变量可能会造成虚假结果（以及接下来的崩溃）。</p>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>在方法签名中，在 -&#x2F;+ 符号后应该有一个空格。方法片段之间也应该有一个空格。</p>
<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setExampleText:(NSString *)text image:(UIImage *)image;</span><br></pre></td></tr></table></figure>

<h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>变量名应该尽可能命名为描述性的。除了 <code>for() </code>循环外，其他情况都应该避免使用单字母的变量名。 星号表示指针属于变量，例如：<code>NSString *text </code>不要写成 <code>NSString* text </code>或者 <code>NSString * text</code> ，常量除外。 尽量定义属性来代替直接使用实例变量。除了初始化方法<code>（init， initWithCoder:，等）</code>， <code>dealloc</code> 方法和自定义的 <code>setters </code>和 <code>getters </code>内部，应避免直接访问实例变量。更多有关在初始化方法和 <code>dealloc</code> 方法中使用访问器方法的信息，参见<a target="_blank" rel="noopener" href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html#//apple_ref/doc/uid/TP40004447-SW6">这里</a>。</p>
<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface NYTSection: NSObject</span><br><span class="line">@property (nonatomic) NSString *headline;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>反对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface NYTSection : NSObject &#123;</span><br><span class="line">    NSString *headline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="变量限定符"><a href="#变量限定符" class="headerlink" title="变量限定符"></a>变量限定符</h6><p>当涉及到在 ARC 中被引入变量限定符时， 限定符 (__strong, __weak, __unsafe_unretained, __autoreleasing) 应该位于星号和变量名之间，如：NSString * __weak text。</p>
<h5 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h5><p>尽可能遵守苹果的命名约定，尤其那些涉及到<a target="_blank" rel="noopener" href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html">内存管理规则</a>，<a target="_blank" rel="noopener" href="http://stackoverflow.com/a/2865194/340508">NARC</a>的。</p>
<p>长的和描述性的方法名和变量名都不错。</p>
<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIButton *settingsButton;</span><br></pre></td></tr></table></figure>

<p>反对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIButton *setBut;</span><br></pre></td></tr></table></figure>

<p>类名和常量应该始终使用三个字母的前缀（例如 NYT），但 Core Data 实体名称可以省略。为了代码清晰，常量应该使用相关类的名字作为前缀并使用驼峰命名法。</p>
<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static const NSTimeInterval NYTArticleViewControllerNavigationFadeAnimationDuration = 0.3;</span><br></pre></td></tr></table></figure>

<p>反对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static const NSTimeInterval fadetime = 1.7;</span><br></pre></td></tr></table></figure>

<p>属性和局部变量应该使用驼峰命名法并且首字母小写。</p>
<p>为了保持一致，实例变量应该使用驼峰命名法命名，并且首字母小写，以下划线为前缀。这与 LLVM 自动合成的实例变量相一致。 如果 LLVM 可以自动合成变量，那就让它自动合成。</p>
<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@synthesize descriptiveVariableName = _descriptiveVariableName;</span><br></pre></td></tr></table></figure>

<p>反对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id varnm;</span><br></pre></td></tr></table></figure>

<h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><p>当需要的时候，注释应该被用来解释 为什么 特定代码做了某些事情。所使用的任何注释必须保持最新否则就删除掉。</p>
<p>通常应该避免一大块注释，代码就应该尽量作为自身的文档，只需要隔几行写几句说明。这并不适用于那些用来生成文档的注释。</p>
<p><code>init </code>和 <code>dealloc</code></p>
<p><code>dealloc </code>方法应该放在实现文件的最上面，并且刚好在<code> @synthesize</code> 和 <code>@dynamic </code>语句的后面。在任何类中，init 都应该直接放在<code>dealloc</code>方法的下面。</p>
<p>init 方法的结构应该像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self = [super init]; // 或者调用指定的初始化方法</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        // Custom initialization</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h5><p>每当创建 <code>NSString</code>，<code> NSDictionary</code>， <code>NSArray</code>，和<code> NSNumber</code> 类的不可变实例时，都应该使用字面量。要注意 <code>nil </code>值不能传给<code>NSArray</code>和 <code>NSDictionary </code>字面量，这样做会导致崩溃。</p>
<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSArray *names = @[@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;];</span><br><span class="line">NSDictionary *productManagers = @&#123;@&quot;iPhone&quot; : @&quot;Kate&quot;, @&quot;iPad&quot; : @&quot;Kamal&quot;, @&quot;Mobile Web&quot; : @&quot;Bill&quot;&#125;;</span><br><span class="line">NSNumber *shouldUseLiterals = @YES;</span><br><span class="line">NSNumber *buildingZIPCode = @10018;</span><br></pre></td></tr></table></figure>

<p>反对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSArray *names = [NSArray arrayWithObjects:@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;, nil];</span><br><span class="line">NSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @&quot;Kate&quot;, @&quot;iPhone&quot;, @&quot;Kamal&quot;, @&quot;iPad&quot;, @&quot;Bill&quot;, @&quot;Mobile Web&quot;, nil];</span><br><span class="line">NSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];</span><br><span class="line">NSNumber *buildingZIPCode = [NSNumber numberWithInteger:10018];</span><br></pre></td></tr></table></figure>

<h5 id="CGRect-函数"><a href="#CGRect-函数" class="headerlink" title="CGRect 函数"></a>CGRect 函数</h5><p>当访问一个 CGRect 的 x， y， width， height 时，应该使用CGGeometry 函数代替直接访问结构体成员。苹果的 CGGeometry 参考中说到：</p>
<blockquote>
<p>All functions described in this reference that take CGRect data structures as inputs implicitly standardize those rectangles before calculating their results. For this reason, your applications should avoid directly reading and writing the data stored in the CGRect data structure. Instead, use the functions described here to manipulate rectangles and to retrieve their characteristics.</p>
</blockquote>
<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CGRect frame = self.view.frame;</span><br><span class="line">CGFloat x = CGRectGetMinX(frame);</span><br><span class="line">CGFloat y = CGRectGetMinY(frame);</span><br><span class="line">CGFloat width = CGRectGetWidth(frame);</span><br><span class="line">CGFloat height = CGRectGetHeight(frame);</span><br></pre></td></tr></table></figure>

<p>反对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CGRect frame = self.view.frame;</span><br><span class="line">CGFloat x = frame.origin.x;</span><br><span class="line">CGFloat y = frame.origin.y;</span><br><span class="line">CGFloat width = frame.size.width;</span><br><span class="line">CGFloat height = frame.size.height;</span><br></pre></td></tr></table></figure>

<h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><p>常量首选内联字符串字面量或数字，因为常量可以轻易重用并且可以快速改变而不需要查找和替换。常量应该声明为 static 常量而不是 #define ，除非非常明确地要当做宏来使用。</p>
<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static NSString * const NYTAboutViewControllerCompanyName = @&quot;The New York Times Company&quot;;</span><br><span class="line">static const CGFloat NYTImageThumbnailHeight = 50.0;</span><br></pre></td></tr></table></figure>

<p>反对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define CompanyName @&quot;The New York Times Company&quot;</span><br><span class="line">#define thumbnailHeight 2</span><br></pre></td></tr></table></figure>

<h5 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h5><p>当使用 <code>enum</code> 时，建议使用新的基础类型规范，因为它具有更强的类型检查和代码补全功能。现在 SDK 包含了一个宏来鼓励使用使用新的基础类型<code> - NS_ENUM()</code></p>
<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, NYTAdRequestState) &#123;</span><br><span class="line">    NYTAdRequestStateInactive,</span><br><span class="line">    NYTAdRequestStateLoading</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="位掩码"><a href="#位掩码" class="headerlink" title="位掩码"></a>位掩码</h5><p>当用到位掩码时，使用 <code>NS_OPTIONS</code> 宏。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, NYTAdCategory) &#123;</span><br><span class="line">    NYTAdCategoryAutos      = 1 &lt;&lt; 0,</span><br><span class="line">    NYTAdCategoryJobs       = 1 &lt;&lt; 1,</span><br><span class="line">    NYTAdCategoryRealState  = 1 &lt;&lt; 2,</span><br><span class="line">    NYTAdCategoryTechnology = 1 &lt;&lt; 3</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h5><p>私有属性应该声明在类实现文件的延展（匿名的类目）中。</p>
<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface NYTAdvertisement ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) GADBannerView *googleAdView;</span><br><span class="line">@property (nonatomic, strong) ADBannerView *iAdView;</span><br><span class="line">@property (nonatomic, strong) UIWebView *adXWebView;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="图片命名"><a href="#图片命名" class="headerlink" title="图片命名"></a>图片命名</h5><p>图片名称应该被统一命名以保持组织的完整。它们应该被命名为一个说明它们用途的驼峰式字符串，其次是自定义类或属性的无前缀名字（如果有的话），然后进一步说明颜色 和&#x2F;或 展示位置，最后是它们的状态。</p>
<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RefreshBarButtonItem / RefreshBarButtonItem@2x 和 RefreshBarButtonItemSelected / RefreshBarButtonItemSelected@2x</span><br><span class="line">ArticleNavigationBarWhite / ArticleNavigationBarWhite@2x 和 ArticleNavigationBarBlackSelected / ArticleNavigationBarBlackSelected@2x.</span><br></pre></td></tr></table></figure>

<p>图片目录中被用于类似目的的图片应归入各自的组中。</p>
<h5 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h5><p>因为 <code>nil </code>解析为 <code>NO</code>，所以没有必要在条件中与它进行比较。永远不要直接和 YES 进行比较，因为 YES 被定义为 1，而 BOOL 可以多达 8 位。</p>
<p>这使得整个文件有更多的一致性和更大的视觉清晰度。</p>
<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (!someObject) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (someObject == nil) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 BOOL 来说, 这有两种用法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (isAwesome)</span><br><span class="line">if (![someObject boolValue])</span><br></pre></td></tr></table></figure>

<p>反对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ([someObject boolValue] == NO)</span><br><span class="line">if (isAwesome == YES) // 永远别这么做</span><br></pre></td></tr></table></figure>

<p>如果一个 <code>BOOL</code> 属性名称是一个形容词，属性可以省略<code>“is”</code>前缀，但为 get 访问器指定一个惯用的名字，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (assign, getter=isEditable) BOOL editable;</span><br></pre></td></tr></table></figure>

<p>内容和例子来自 Cocoa 命名指南 。</p>
<h5 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h5><p>单例对象应该使用线程安全的模式创建共享的实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)sharedInstance &#123;</span><br><span class="line">    static id sharedInstance = nil;</span><br><span class="line"></span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedInstance = [[self alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将会预防有时可能产生的许多崩溃。</p>
<h5 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h5><p>如果有一个以上的 import 语句，就对这些语句进行分组。每个分组的注释是可选的。 注：对于模块使用 @import 语法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Frameworks</span><br><span class="line">@import QuartzCore;</span><br><span class="line"></span><br><span class="line">// Models</span><br><span class="line">#import &quot;NYTUser.h&quot;</span><br><span class="line"></span><br><span class="line">// Views</span><br><span class="line">#import &quot;NYTButton.h&quot;</span><br><span class="line">#import &quot;NYTUserView.h&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Part1-3：-代码注释规范"><a href="#Part1-3：-代码注释规范" class="headerlink" title="Part1-3： 代码注释规范"></a>Part1-3： 代码注释规范</h3><p>当需要的时候，注释应该被用来解释 为什么 特定代码做了某些事情。所使用的任何注释必须保持最新，否则就删除掉。</p>
<p>通常应该避免一大块注释，代码就应该尽量作为自身的文档，只需要隔几行写几句说明。这并不适用于那些用来生成文档的注释。</p>
<p>#####文件注释<br>采用Xcode自动生成的注释格式，修改部分参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  AppDelegate.m</span><br><span class="line">//  oc code good</span><br><span class="line">//</span><br><span class="line">//  Created by roycms on 16-10-30.</span><br><span class="line">//  Copyright (c) 2016 roycms.cn LLC. All rights reserved.</span><br><span class="line">//</span><br></pre></td></tr></table></figure>

<p>其中<code>项目名称</code>、<code>创建人</code>、<code>公司版权</code>需要填写正确。</p>
<h5 id="import注释"><a href="#import注释" class="headerlink" title="import注释"></a>import注释</h5><p>如果有一个以上的 import 语句，就对这些语句进行<code>[分组][Import_1]</code>。每个分组的注释是可选的。<br>注：对于模块使用<code> [@import][Import_2]</code> 语法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Frameworks</span><br><span class="line">@import QuartzCore;</span><br><span class="line"></span><br><span class="line">// Models</span><br><span class="line">#import &quot;NYTUser.h&quot;</span><br><span class="line"></span><br><span class="line">// Views</span><br><span class="line">#import &quot;NYTButton.h&quot;</span><br><span class="line">#import &quot;NYTUserView.h&quot;</span><br></pre></td></tr></table></figure>

<h5 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h5><p>采用javadoc的格式，可以使用XCode插件VVDocumenter-Xcode快速添加，只需输入&#x2F;&#x2F;&#x2F;即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  功能描述</span><br><span class="line"> *</span><br><span class="line"> *  @param tableView 参数说明</span><br><span class="line"> *  @param section   参数说明</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回值说明</span><br><span class="line"> */</span><br><span class="line">- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section&#123;</span><br><span class="line">    return [self.familyNames objectAtIndex:section];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="代码块注释"><a href="#代码块注释" class="headerlink" title="代码块注释"></a>代码块注释</h5><p>单行的用<code>//</code>+空格开头，多汗的采用<code>/* */</code>注释 <code>##TODO</code>注释 TODO 很不错, 有时候, 注释确实是为了标记一些未完成的或完成的不尽如人意的地方, 这样一搜索, 就知道还有哪些活要干, 日志都省了。</p>
<p>格式：<code>//TODO</code>:说明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123;</span><br><span class="line">    //TODO:增加初始化</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更多规范"><a href="#更多规范" class="headerlink" title="更多规范"></a>更多规范</h4><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/roycms/IosCodeSpecification">切图规范</a></li>
</ul>
<h4 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h4><p><a target="_blank" rel="noopener" href="https://github.com/iamlay/IosCodeSpecification">iOSCodeSpecification</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://iamlay.com/2020/08/26/iOSCodeSpecification/" data-id="clfj8cp2q001qfbf3hxiobag6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HexoGoogleAnalytics" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/27/HexoGoogleAnalytics/" class="article-date">
  <time datetime="2020-06-27T04:02:27.000Z" itemprop="datePublished">2020-06-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BD%91%E7%AB%99/">网站</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/27/HexoGoogleAnalytics/">Hexo的Next主题中配置Google Analytics之后不生效的问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p> 最近在优化Hexo博客，添加网站分析的功能，在配置Google Analytics之后，一直无法生效，最终发现是因为网站配置文件<code>_config.yml</code>中配置的<code>url</code>和 <code>GitHub Pages</code>的<code>自定义域名</code>不一致导致的。如果没有配置<code>自定义域名</code>的话应该没有问题，但是如果<code>配置了自定义域名</code>的话，一定要保证网站配置文件<code>_config.yml</code>中配置的<code>url</code>和 <code>GitHub Pages</code>的<code>自定义域名</code>一致。</p>
</blockquote>
<p>####Part01 - Google Analytics配置<br><code>Google Analytics</code>的配置非常简单，使用<code>NexT</code>主题的用户在<code>Google Analytics官网</code>获取到<code>tracking_id</code>,并在<code>NexT主题配置文件</code>配置好</p>
<ol>
<li>获取<code>tracking_id</code><br><img src="/./GoogleAnalytics01.png" alt="Alt text"></li>
<li>在<code>NexT</code>主题配置文件<code>_config.ym</code>配置<code>tracking_id</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Google Analytics</span><br><span class="line">google_analytics:</span><br><span class="line">  tracking_id: UA-170943611-2</span><br><span class="line">  # By default, NexT will load an external gtag.js script on your site.</span><br><span class="line">  # If you only need the pageview feature, set the following option to true to get a better performance.</span><br><span class="line">  only_pageview: false</span><br></pre></td></tr></table></figure></li>
<li>然后执行Hexo部署命令，部署到网站<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo c</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
我们来看一下网站中关于<code>Google Analytics</code>的代码,只有<code>CONGIG.hostname</code>和<code>location.hostname</code>一致的时候才会生效，自己可以在控制台打印一下两者是不是一致。那么<code>CONGIG.hostname</code>和<code>location.hostname</code>都是在哪里配置的呢？？？<br><img src="/./GoogleAnalytics02.png" alt="Alt text"></li>
</ol>
<p>####Part02 - 配置<code>CONGIG.hostname</code>和<code>location.hostname</code></p>
<ol>
<li>配置<code>CONGIG.hostname</code></li>
</ol>
<p>正如上文所说，<code>CONGIG.hostname</code>指向得是<code>Hexo</code>根目录下<code>_config.yml</code>中配置的<code>url</code><br><img src="/./GoogleAnalytics03.png" alt="Alt text"></p>
<ol start="2">
<li>配置<code>location.hostname</code><br><code>location.hostname</code>指向的是<code>Github网站</code>中仓库的<code>Github Page</code>配置的<code>自定义域名</code></li>
</ol>
<p><img src="/./GoogleAnalytics04.png" alt="Alt text"></p>
<p>到这里基本就配置完毕了，可以看下实际效果</p>
<p><img src="/./GoogleAnalytics05.png" alt="Alt text"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://iamlay.com/2020/06/27/HexoGoogleAnalytics/" data-id="clfj8cp29000afbf3hvr9571g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-VPN" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/25/VPN/" class="article-date">
  <time datetime="2020-06-25T03:03:44.000Z" itemprop="datePublished">2020-06-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/25/VPN/">以技术之名周报07#| 推荐一款稳定的VPN - Cloudss| 2020-06-25</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Part01-背景"><a href="#Part01-背景" class="headerlink" title="Part01- 背景"></a>Part01- 背景</h4><blockquote>
<p>对一个开发人员来讲，学会科学上网非常重要。有一些插件使用国内的网络下载非常慢或者直接无法下载，非常的让人捉急。在开发中遇到无法解决的问题的时候，我们很可能求助各种技术网站或者emmmm — 百度。</p>
<p>使用百度的弊端显而易见：搜索结果前排是一大堆的广告，后面跟着千篇一律的答案，要在各种转载复制的文章中找到最佳的解决方案非常耗费时间。我曾经遇到一个问题，使用百度一个下午一无所获，换成Google之后五分解决问题，这件事情直接导致我放弃使用百度搜索，转向Google搜索。</p>
</blockquote>
<p> 但是，因为众所周知的原因Google是没有办法访问的，对很多人来讲找到一款便宜稳定的<code>VPN</code>又要花费非常多的时间。相信初级开发者都使用过广为推荐的<code>蓝灯</code>，我最早使用的VPN也是<code>蓝灯</code>，但是免费版本的<code>蓝灯</code>一方面限速限量，另一方面在国内开各种会议的时候直接嗝屁。非常影响体验。后来走上了自己购买国外服务器搭梯子的道路：我当时是在<code>Vultr.com</code>上面买的服务器，然后使用<code>Outline</code>上网，但是在国内两会期间也会被墙，感觉自己搭建服务器花费的时间成本和获得体验是不成正比的，就放弃了。</p>
<p>后来同事推荐了一个VPN购买网站<a target="_blank" rel="noopener" href="https://store.cloudss.org/aff.php?aff=5579">CloudSS</a>，<a target="_blank" rel="noopener" href="https://store.cloudss.org/aff.php?aff=5579">CloudSS</a>提供的是<code>V2Ray</code>    服务，到现在用了差不多9个月的时间，中间没有出现过被墙，即便是在国内两会期间也非常稳定，所以给大家种草。<br>![Alt text](.&#x2F;截屏2020-06-25 下午2.58.03.png)</p>
<p>大家无需翻墙，可以直接访问<a target="_blank" rel="noopener" href="https://store.cloudss.org/aff.php?aff=5579">ClodSS的官网</a>,没查出来<a target="_blank" rel="noopener" href="https://store.cloudss.org/aff.php?aff=5579">ClodSS</a>是哪里的公司，但是官网支持<code>英语</code>和<code>汉语</code>两种语言：<img src="/./VPN02.png" alt="Alt text"></p>
<h4 id="Part02-购买"><a href="#Part02-购买" class="headerlink" title="Part02- 购买"></a>Part02- 购买</h4><p><code>用户中心</code> -&gt; <code>购买服务</code> -&gt;<code>购买页面</code>-&gt;<code>立即订购</code>-&gt;<code>支付</code> -&gt;<code>购买成功</code></p>
<p><strong>购买服务入口：</strong><br><img src="/./VPN03.png" alt="Alt text"></p>
<p><strong>服务选择页面：</strong></p>
<p><img src="/./VPN04.png" alt="Alt text"></p>
<hr>
<h2 id="这里说下，CloudSS有四种产品：-V2-Trail-3G-A-、V2-25G-A-、V2-S1-A-、V2-S2-A。-这几种产品都支持iOS、Android、Windows、Mac四种类型的设备"><a href="#这里说下，CloudSS有四种产品：-V2-Trail-3G-A-、V2-25G-A-、V2-S1-A-、V2-S2-A。-这几种产品都支持iOS、Android、Windows、Mac四种类型的设备" class="headerlink" title="这里说下，CloudSS有四种产品： V2-Trail-3G-A 、V2-25G-A 、V2-S1-A 、V2-S2-A。 这几种产品都支持iOS、Android、Windows、Mac四种类型的设备"></a><strong>这里说下，<a target="_blank" rel="noopener" href="https://store.cloudss.org/aff.php?aff=5579">CloudSS</a>有四种产品： <code>V2-Trail-3G-A</code> 、<code>V2-25G-A</code> 、<code>V2-S1-A</code> 、<code>V2-S2-A</code>。 这几种产品都支持iOS、Android、Windows、Mac四种类型的设备</strong></h2><h5 id="V2-Trail-3G-A"><a href="#V2-Trail-3G-A" class="headerlink" title="V2-Trail-3G-A"></a>V2-Trail-3G-A</h5><p>3G流量，可以使用7天，$9.9,<br>但是可以在支付的时候填<code>v2ray</code>的优惠码，价格就变成0.2$了，每个人一次机会，相当于体验版,不限制同时使用的设备数量;</p>
<p><img src="/./VPN05.png" alt="Alt text"></p>
<h5 id="V2-25G-A"><a href="#V2-25G-A" class="headerlink" title="V2-25G-A"></a>V2-25G-A</h5><p>25G流量，使用30天，不限制设备数量，不限制节点数量<br><img src="/./VPN06.png" alt="Alt text"></p>
<h5 id="V2-S1-A"><a href="#V2-S1-A" class="headerlink" title="V2-S1-A"></a>V2-S1-A</h5><p>每月128G流量，使用半年，最多5台设备同时登录，不限制节点数量</p>
<p><img src="/./VPN07.png" alt="Alt text"></p>
<h5 id="V2-S2-A"><a href="#V2-S2-A" class="headerlink" title="V2-S2-A"></a>V2-S2-A</h5><p>每月256G流量，使用一年，最多5台设备同时登录，不限制节点数量</p>
<p><img src="/./VPN08.png" alt="Alt text"></p>
<p>大家可以根据自己的需要选好需要的产品，然后加到购物车，支付就可以了。支持<code>支付宝</code>和<code>Paypal</code>两种支付方式。<br><img src="/./VPN09.png" alt="Alt text"></p>
<p><img src="/./VPN10.png" alt="Alt text"></p>
<h4 id="Part03-使用服务"><a href="#Part03-使用服务" class="headerlink" title="Part03- 使用服务"></a>Part03- 使用服务</h4><p>购买成功之后，可以在网站看到自己购买的服务，如图：</p>
<p><img src="/./VPN11.png" alt="Alt text"></p>
<p>点击购买的服务，进入到服务页面，可以看到：<br><img src="/./VPN12.png" alt="Alt text"></p>
<p>大家可以先根据第一步的<code>使用教程</code>，下载下来自己设备需要的软件，安装完成之后，将第二步中<code>复制的地址</code>添加到软件中,然后就可以愉快的上网了。看一下<code>使用教程页面</code>:<br><img src="/./VPN13.png" alt="Alt text"></p>
<p>使用教程页面给出了每种平台使用的软件的下载地址，并给出了配置的详细步骤，这里我就不多说了。有一个细节非常值得一提，因为我使用的移动设备是iOS，使用的软件是<code>Shadowrocket</code>,但是<code>Shadowrocket</code>在中国区是不能下载的，而且也是一个付费软件，<a target="_blank" rel="noopener" href="https://store.cloudss.org/aff.php?aff=5579">CloudSS</a>给免费提供了下载<code>Shadowrocket</code>的账号和密码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Apple商店账号：acc@shadowrocket.online</span><br><span class="line">Apple商店密码：88FREE@shadowrocket.online</span><br></pre></td></tr></table></figure>

<p>现在，我们来看看效果：</p>
<p>Mac端：<br><img src="/./VPN14.png" alt="Alt text"></p>
<p>iPhone端：</p>
<p><img src="/./VPN15.png" alt="Alt text"></p>
<p>希望这篇文章对大家有帮助，避免浪费更多的时间在稂莠不齐的VPN中，提升大家的生产力！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://iamlay.com/2020/06/25/VPN/" data-id="clfj8cp2o001kfbf31l7b8jpa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-week19" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/10/week19/" class="article-date">
  <time datetime="2020-05-10T12:58:53.000Z" itemprop="datePublished">2020-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/10/week19/">以技术之名周报06#| ReactiveCocoa入门篇| 2020-05-10</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Part-01-背景"><a href="#Part-01-背景" class="headerlink" title="Part-01 背景"></a>Part-01 背景</h3><p>作为一个iOS开发者，写的每一行代码都是对事件的反馈，像Button点击、网络请求、属性改变（KVO）、用户位置改变等。但是这些事件的处理采用的是Actions、delegate、KVO、回调等不同的方式。<a target="_blank" rel="noopener" href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>针对不同的事件定义了的标准接口，这样不同的事件可以更容易链式调用、过滤、组合。</p>
<p>ReactiveCocoa组合了一对编程范式：<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Functional_programming">函数式编程</a>：使用更高级别的函数，该函数用其他函数作为他的参数。<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Reactive_programming">响应式编程</a>:一种面向数据流和变化传播的声明式编程范式。所以，ReactiveCocoa也被称之为函数响应式编程框架。</p>
<p>ReactiveCocoa教程马上开始，接下来的教程侧重点在实用价值，所以给出的是实操而不是长篇大论。</p>
<h3 id="Part-02-实践"><a href="#Part-02-实践" class="headerlink" title="Part-02 实践"></a>Part-02 实践</h3><h4 id="ReactivePlayground"><a href="#ReactivePlayground" class="headerlink" title="ReactivePlayground"></a>ReactivePlayground</h4><p>在接下来的整个ReactiveCocoa教程中，我们将通过ReactivePlayground这个应用来逐步引入响应式编程。下载<a target="_blank" rel="noopener" href="https://koenig-media.raywenderlich.com/uploads/2014/01/ReactivePlayground-Starter.zip">ReactivePlayground工程</a>，确保可以正常的build和run.</p>
<p>ReactivePlaygroun是一款非常简单的应用，主要就是给用户展示了一个登录的页面。输入用户的账号和密码，验证通过之后，进入到一个有一只可爱猫咪的页面。</p>
<p><img src="/./week1901.jpg" alt="Alt text"></p>
<p>打开工程，找到  <strong>RWViewController.m</strong>文件，你花费多久的时间可以找到<strong>Sign In</strong> Button变成enabing状态所需要的条件？展示&#x2F;隐藏 <strong>signInFaulure</strong> Label的规则是什么？ 也许，你花费两三分钟的时间就可以回答这些问题，但是当你面对更加复杂的项目的时候，你分析同样的问题可能就会花费相当长的时间。</p>
<p>这就是ReactiveCocoa的优势所在，ReactiveCocoa能够让应用程序的基本意图变得更加清晰。那让我们开始我们的工作吧！！！</p>
<h4 id="添加ReactiveCocoa框架"><a href="#添加ReactiveCocoa框架" class="headerlink" title="添加ReactiveCocoa框架"></a>添加ReactiveCocoa框架</h4><p>最方便的方式就是通过<a target="_blank" rel="noopener" href="http://cocoapods.org/">CocoaPods.</a>的方式导入框架。如果在此之前你没有使用过<a target="_blank" rel="noopener" href="http://cocoapods.org/">CocoaPods.</a>，可以按照本网站的<a target="_blank" rel="noopener" href="https://www.raywenderlich.com/?p=12139">CocoaPods 入门教程</a>进行操作，或者至少通过该教程的初始步骤进行操作，以便安装必备的组件。</p>
<blockquote>
<p>如果因为某些原因你不想引入CocoaPods，你仍旧可以通过其他的方式使用ReactiveCocoa。可以参考Github上面的<a target="_blank" rel="noopener" href="https://github.com/ReactiveCocoa/ReactiveCocoa#importing-reactivecocoa">引入ReactiveCocoa</a>文档，一步步操作。</p>
</blockquote>
<p>打开终端，进入到下载工程的根目录，执行下面的指令创建Podfile文件；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch Podfile</span><br><span class="line">open -e Podfile</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用文本编辑器打开Podfile文件，复制下面的代码到里面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &#x27;7.0&#x27;</span><br><span class="line">pod &#x27;ReactiveCocoa&#x27;, &#x27;2.1.8&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这两句代码的意思是设置iOS平台且最小支持的版本是7.0、添加ReactiveCocoa框架作为依赖。保存文件，继续在终端执行下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod install</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你会看到终端打印出类似下面的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Analyzing dependencies</span><br><span class="line">Downloading dependencies</span><br><span class="line">Installing ReactiveCocoa (2.1.8)</span><br><span class="line">Generating Pods project</span><br><span class="line">Integrating client project</span><br><span class="line"></span><br><span class="line">[!] From now on use `RWReactivePlayground.xcworkspace`.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这意味着ReactiveCocoa framework已经被下载下来了，CocoaPods创建一个Xcode workspace文件将应用和framework整合起来了</p>
<p><img src="/./week1902.png" alt="Alt text"></p>
<h4 id="开始实施"><a href="#开始实施" class="headerlink" title="开始实施"></a>开始实施</h4><p>正如上面介绍中提到的，ReacticeCocoa为应用程序中发生的事件流提供了一个标准的接口。这种接口在ReactiveCocoa中称为信号(Signal),通过<code>RACSignal</code>类来表示。</p>
<p>打开<code> RWViewController.m</code>文件，引入ReactiveCocoa头文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>暂时先不用替换任何现有代码，只需要做一些操作即可。添加下面的代码到<code>viewDidload</code>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[self.usernameTextField.rac_textSignal subscribeNext:^(id x)&#123;</span><br><span class="line">  NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行应用程序，在username textField中输入文字，查看控制台输出的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">2013-12-24 14:48:50.359 RWReactivePlayground[9193:a0b] i</span><br><span class="line">2013-12-24 14:48:50.436 RWReactivePlayground[9193:a0b] is</span><br><span class="line">2013-12-24 14:48:50.541 RWReactivePlayground[9193:a0b] is </span><br><span class="line">2013-12-24 14:48:50.695 RWReactivePlayground[9193:a0b] is t</span><br><span class="line">2013-12-24 14:48:50.831 RWReactivePlayground[9193:a0b] is th</span><br><span class="line">2013-12-24 14:48:50.878 RWReactivePlayground[9193:a0b] is thi</span><br><span class="line">2013-12-24 14:48:50.901 RWReactivePlayground[9193:a0b] is this</span><br><span class="line">2013-12-24 14:48:51.009 RWReactivePlayground[9193:a0b] is this </span><br><span class="line">2013-12-24 14:48:51.142 RWReactivePlayground[9193:a0b] is this m</span><br><span class="line">2013-12-24 14:48:51.236 RWReactivePlayground[9193:a0b] is this ma</span><br><span class="line">2013-12-24 14:48:51.335 RWReactivePlayground[9193:a0b] is this mag</span><br><span class="line">2013-12-24 14:48:51.439 RWReactivePlayground[9193:a0b] is this magi</span><br><span class="line">2013-12-24 14:48:51.535 RWReactivePlayground[9193:a0b] is this magic</span><br><span class="line">2013-12-24 14:48:51.774 RWReactivePlayground[9193:a0b] is this magic?</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，每当改变textfield内容的时候，block中的代码都会执行。这里既没有target-action、也没有代理方法，仅仅用到了signals和block，令人激动万分！</p>
<p>ReactiveCocoa的 <code>信号</code>（通过RACSignal表示）发送事件流给它的订阅者。主要是有三种类型的事件：<code>next</code>、<code>error</code>、<code>completed</code>. 信号会因为<code>error</code>或者<code>complete</code>结束，但在结束之前可以发送任意数量的<code>next</code>事件。</p>
<p><code>RACSignal</code>有多种方法用于订阅不同的事件类型，每种方法都一个或者多个block，事件发生的时候可以用来执行你想要的逻辑。比如：<code>subscribeNext:</code>方法就提供了这样一个block，每当<code>next</code>事件发生的时候，就会执行该block;</p>
<p>ReactiveCocoa框架通过<code>类别</code>给标准的UIKit控件添加信号，因此你可以订阅这些控件的事件。这就是你可以在textfield上使用<code>rac_textSignal</code>属性的原因。</p>
<p>ReactiveCocoa有大量的可以用来操纵事件流的<code>操作符</code>。比如：你只对长度超过三个字符的用户名感兴趣，那么就可以使用    <code>filter</code>操作符。将viewDidload中添加的代码更新为下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[self.usernameTextField.rac_textSignal</span><br><span class="line">  filter:^BOOL(id value) &#123;</span><br><span class="line">    NSString *text = value;</span><br><span class="line">    return text.length &gt; 3;</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行程序，然后在文本框继续输入字符，你会发现控制台在textfield的内容长度超过3的时候才打印：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2013-12-26 08:17:51.335 RWReactivePlayground[9654:a0b] is t</span><br><span class="line">2013-12-26 08:17:51.478 RWReactivePlayground[9654:a0b] is th</span><br><span class="line">2013-12-26 08:17:51.526 RWReactivePlayground[9654:a0b] is thi</span><br><span class="line">2013-12-26 08:17:51.548 RWReactivePlayground[9654:a0b] is this</span><br><span class="line">2013-12-26 08:17:51.676 RWReactivePlayground[9654:a0b] is this </span><br><span class="line">2013-12-26 08:17:51.798 RWReactivePlayground[9654:a0b] is this m</span><br><span class="line">2013-12-26 08:17:51.926 RWReactivePlayground[9654:a0b] is this ma</span><br><span class="line">2013-12-26 08:17:51.987 RWReactivePlayground[9654:a0b] is this mag</span><br><span class="line">2013-12-26 08:17:52.141 RWReactivePlayground[9654:a0b] is this magi</span><br><span class="line">2013-12-26 08:17:52.229 RWReactivePlayground[9654:a0b] is this magic</span><br><span class="line">2013-12-26 08:17:52.486 RWReactivePlayground[9654:a0b] is this magic?</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其实，在这里你创建了一个非常简单的管道。这就是响应式编程的本质，通过数据流的方式来表达应用程序的功能。下面的图片看起来更为直观：<br><img src="/./week1903.png" alt="Alt text"></p>
<p>上图可以看到，<code>rac_textSignal</code>是事件的初始来源，数据流通过一个<code>filter</code>过滤,该<code>filter</code>仅允许字符长度大于等于3的事件通过。该管道的最后一步是<code>subscribeNext:</code>,在这一步可以通过block打印事件的值。</p>
<p>这里需要注意的一点是，<code>filter</code>的返回值也是<code>RACSignal</code>,可以通过下面的方式揭示管道的执行过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *usernameSourceSignal = </span><br><span class="line">    self.usernameTextField.rac_textSignal;</span><br><span class="line"></span><br><span class="line">RACSignal *filteredUsername = [usernameSourceSignal  </span><br><span class="line">  filter:^BOOL(id value) &#123;</span><br><span class="line">    NSString *text = value;</span><br><span class="line">    return text.length &gt; 3;</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">[filteredUsername subscribeNext:^(id x) &#123;</span><br><span class="line">  NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为在<code>RACSignal</code>执行的每一种操作符返回还是<code>RACSignal</code>,因此也被称为<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Fluent_interface">fluentinterface</a>。该功能可以使你构造管道，而无需用局部变量引用每个步骤。<br>    &gt; Note: ReacticeCocoa使用了大量的blocks。如果你之前没有接触过block,你应该先看看Apple的<a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/Blocks/Articles/00_Introduction.html">Blocks Programming Topics</a>,如果你像我一样对block很熟悉，但是对语法有点疑惑的话，可以访问<a target="_blank" rel="noopener" href="http://fuckingblocksyntax.com/">http://fuckingblocksyntax.com/</a>来巩固下你的知识。</p>
<p>####隐式转换</p>
<p>将之前的拆分的代码恢复成流式语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[self.usernameTextField.rac_textSignal</span><br><span class="line">  filter:^BOOL(id value) &#123;</span><br><span class="line">    NSString *text = value; // implicit cast</span><br><span class="line">    return text.length &gt; 3;</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>上面指定位置代码的隐式转换不够优雅，因为传递给该block的值始终是NSString类型，所以可以直接更改参数类型本身，更新代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[self.usernameTextField.rac_textSignal</span><br><span class="line">  filter:^BOOL(NSString *text) &#123;</span><br><span class="line">    return text.length &gt; 3;</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行代码，会发现和之前的效果一致。</p>
<h4 id="什么是-【事件-】？"><a href="#什么是-【事件-】？" class="headerlink" title="什么是 【事件 】？"></a>什么是 【事件 】？</h4><p>到目前为止，本教程已经描述了不同的事件类型，但是没有详细介绍这些事件的结构。有趣的是，事件可以包含任何东西！</p>
<p>为了证明这一点，向该管道添加另一种操作符，更新代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[[[self.usernameTextField.rac_textSignal</span><br><span class="line">  map:^id(NSString *text) &#123;</span><br><span class="line">    return @(text.length);</span><br><span class="line">  &#125;]</span><br><span class="line">  filter:^BOOL(NSNumber *length) &#123;</span><br><span class="line">    return [length integerValue] &gt; 3;</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行代码，发现控制台将会打印text field的内容长度而不是内容本身：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2013-12-26 12:06:54.566 RWReactivePlayground[10079:a0b] 4</span><br><span class="line">2013-12-26 12:06:54.725 RWReactivePlayground[10079:a0b] 5</span><br><span class="line">2013-12-26 12:06:54.853 RWReactivePlayground[10079:a0b] 6</span><br><span class="line">2013-12-26 12:06:55.061 RWReactivePlayground[10079:a0b] 7</span><br><span class="line">2013-12-26 12:06:55.197 RWReactivePlayground[10079:a0b] 8</span><br><span class="line">2013-12-26 12:06:55.300 RWReactivePlayground[10079:a0b] 9</span><br><span class="line">2013-12-26 12:06:55.462 RWReactivePlayground[10079:a0b] 10</span><br><span class="line">2013-12-26 12:06:55.558 RWReactivePlayground[10079:a0b] 11</span><br><span class="line">2013-12-26 12:06:55.646 RWReactivePlayground[10079:a0b] 12</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>新增的<code>map</code>操作通过提供的block来转换事件数据流。对于接收到的每一个<code>next</code>事件，它都会执行该block, 然后发出返回值，该返回值仍旧是一个<code>next</code>事件。上面的代码中，    <code>map</code>操作符拿到<code>NSString</code>类型的值，获得其长度，并将其转换成<code>NSNumber</code>类型返回。</p>
<p>有关此功能的图形描述，可以看下面的图片：<br><img src="/./week1904.png" alt="Alt text"></p>
<p>如你所见，<code>map</code>操作符之后的所有的步骤收到的都是<code>NSNumber</code>实例。你可以使用<code>map</code>操作符将收到数据转换成任意类型的对象。</p>
<blockquote>
<p>Note: 上面代码中的text.length 返回的是NSInteger类型，它是一种基本类型。为了将其作为事件的内容来使用，必须将其进行包装。Objectice-C提供了一种简洁的字面量语法来进行此此操作@(texr.length)</p>
</blockquote>
<p>现在应该使用所学的概念来更新<strong>ReactivePlayground</strong>的代码。</p>
<h4 id="创建-Valid-State-Signals"><a href="#创建-Valid-State-Signals" class="headerlink" title="创建 Valid State Signals"></a>创建 Valid State Signals</h4><p>首先要做的就是，创建一对信号来指示<code>username</code>和<code>password</code>是否是有效的。在<strong>RWViewController.m</strong>的viewDidload方法中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *validUsernameSignal =</span><br><span class="line">  [self.usernameTextField.rac_textSignal</span><br><span class="line">    map:^id(NSString *text) &#123;</span><br><span class="line">      return @([self isValidUsername:text]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *validPasswordSignal =</span><br><span class="line">  [self.passwordTextField.rac_textSignal</span><br><span class="line">    map:^id(NSString *text) &#123;</span><br><span class="line">      return @([self isValidPassword:text]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如你所见，上面的代码将<code>map</code>操作符应用到每一个textfield的<code>rac_textSignal</code>，输出由Bool值封装的NSNumber对象。</p>
<p>接下来继续转换这些信号，以便它们能够为textfield提供合适的背景色。你通过订阅这些信号，拿到相应的值就可以更新textfield的背景色，一个可行的选择如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[validPasswordSignal</span><br><span class="line">  map:^id(NSNumber *passwordValid) &#123;</span><br><span class="line">    return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(UIColor *color) &#123;</span><br><span class="line">    self.passwordTextField.backgroundColor = color;</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>先不要添加上面的代码，因为我们还有更加优雅的方式。</p>
<p>我们的目的是将信号的输出值赋值给textfield的background属性，但是上面的代码并不具备很好的表达性，赋值语句太过于靠后了。</p>
<p>幸运的是ReactiveCocoa有一个宏定义，允许你更加优雅的来表达这个功能。将下面的代码直接添加到viewDidload中两个signals的下方。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RAC(self.passwordTextField, backgroundColor) =</span><br><span class="line">  [validPasswordSignal</span><br><span class="line">    map:^id(NSNumber *passwordValid) &#123;</span><br><span class="line">      return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">RAC(self.usernameTextField, backgroundColor) =</span><br><span class="line">  [validUsernameSignal</span><br><span class="line">    map:^id(NSNumber *passwordValid) &#123;</span><br><span class="line">     return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>RAC</code>宏定义允许你将信号的输出赋值给对象的属性，它需要两个参数，第一个是包含要设置属性的对象。第二个是参数是属性名称。每次信号发出下一个事件时，传递的值都会赋值给给定的属性。</p>
<p>是不是非常优雅的解决方案？</p>
<p>最后一件要做的事情是移除洗面的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.usernameTextField.backgroundColor = self.usernameIsValid ? [UIColor clearColor] : [UIColor yellowColor];</span><br><span class="line">self.passwordTextField.backgroundColor = self.passwordIsValid ? [UIColor clearColor] : [UIColor yellowColor];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过下面的图像，可视化当前的逻辑。可以看到，这里有两个简单的管道，它们获取文本信号，然后通过<code>map</code>将它们映射为有指示有效性的Bool值，然后再映射为UIColor,将UIcolor绑定到textfield 的backgroundcolor上。<br><img src="/week1905.png" alt="Alt text"></p>
<p>你是否好奇，为什么创建了两个分离的信号<code>validPasswordSignal</code>和<code>validUsernameSignal</code>,而不是为每个textfield创建一个单一的流畅管道。保持耐心，这种疯狂背后的方法很快将变得清晰！！！</p>
<h4 id="Combining-signals-组合信号"><a href="#Combining-signals-组合信号" class="headerlink" title="Combining signals (组合信号)"></a>Combining signals (组合信号)</h4><p>当前情况下， <strong>Sigin  In</strong>Button只有在username和password输入框都有效的情况下才能点击，是时候通过响应式的方式来做这件事情了。</p>
<p>当前的代码已经有能发出boolean类型值的<strong>信号</strong>，来显示username和password是否是有效的：<code>validUsernameSignal</code>和<code>validPasswordSignal</code>。你要做的就是将这两种信号组合起来，以确定何时是该Button处于enable状态。</p>
<p>在viewDidload方法中添加下面的代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signUpActiveSignal = [RACSignal combineLatest:@[validUsernameSignal, validPasswordSignal]</span><br><span class="line">   reduce:^id(NSNumber *usernameValid, NSNumber *passwordValid) &#123;</span><br><span class="line">        return @([usernameValid boolValue] &amp;&amp; [passwordValid boolValue]);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<p>上面的代码通过<code>combineLatest:reduce:</code>方法组合<code>validUsernameSignal</code>和<code>validPasswordSignal</code>提交的最新值成为一个新的信号。每当两个信号中的任意一个提交了新值<code>reduce</code> block都会执行,其返回值将成为<code>组合信号</code>的下一个值。</p>
<blockquote>
<p>RACSignal组合方法可以组合任意数量的信号，reduce block中的参数对应着每个<code>源信号</code>的值。ReacticeCocoa有一个小的实用类<code>RACBlockTrampoline</code>,该类用来处理reduce block中的可变参数列表。</p>
</blockquote>
<p>现在你就有了一个合适的信号，继续添加下面的代码到    <code>viewDidload</code>方法的最后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[signUpActiveSignal subscribeNext:^(NSNumber *signupActive) &#123;</span><br><span class="line">   self.signInButton.enabled = [signupActive boolValue];</span><br><span class="line"> &#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在运行程序之前，移除下面的属性和代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic) BOOL passwordIsValid;</span><br><span class="line">@property (nonatomic) BOOL usernameIsValid;</span><br><span class="line"></span><br><span class="line">----------------------------</span><br><span class="line">// handle text changes for both text fields</span><br><span class="line">[self.usernameTextField addTarget:self</span><br><span class="line">                           action:@selector(usernameTextFieldChanged)</span><br><span class="line">                 forControlEvents:UIControlEventEditingChanged];</span><br><span class="line">[self.passwordTextField addTarget:self </span><br><span class="line">                           action:@selector(passwordTextFieldChanged)</span><br><span class="line">                 forControlEvents:UIControlEventEditingChanged];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同时也移除<code>updateUIState</code>、<code>usernameTextFieldChange</code>和<code>passwordTextfieldChange</code>方法。最后确保移除viewDidload中对<code>updateUIState</code>的调用。</p>
<p>运行程序，测试<strong>Sign In</strong> button，当username和password都是有效的时候，<code>Sign In</code> Button应该也是enabled的。这个逻辑如下图：<br><img src="/./week1906.png" alt="Alt text"></p>
<p>上图揭示了一对非常重要的概念，这对概念可以让你用ReactiveCocoa执行非常强大的任务</p>
<ul>
<li>拆分 - 信号可以有多个订阅者，并充当多个后续管道步骤的源。上图中，指示username和password有效性的boolean信号被拆分，并用于不同的目的。</li>
<li>组合 - 可以组合多个信号创建新的信号，上图只是组合的boolean信号，实际上你可以组合任意类型的信号。</li>
</ul>
<p>这些更改的结果是不再需要指示两个textfield是否有效的私有属性，这是使用响应式的主要特征之一 ： 不再需要实例变量来追踪瞬时状态。</p>
<h4 id="Reactice-Sign-In-（响应式登录）"><a href="#Reactice-Sign-In-（响应式登录）" class="headerlink" title="Reactice Sign-In （响应式登录）"></a>Reactice Sign-In （响应式登录）</h4><p>目前为止，只有管理textfield和button的状态使用到了响应式编程的方式，但是按钮的点击事件处理仍旧在使用action的方式，接下来要做的就是用响应式的方式来做替代action的方式。</p>
<p><code>Sign In</code> Button的点击事件通过<code>storyboard action</code>的方式写在了<code>RWViewController.m</code>的<code>signInButtonTouched</code>中。我们要做的就是取代这种方式，所以第一步就是做的就是断开和storyboard action的关联。</p>
<p>打开<code>Main.storyboard</code>,找到<code>Sign In</code> Button,点击<code>crtl</code>键打开<code>outlet/action</code>连接，点击X移除连接，下图显示在哪里可以找到删除按钮：<br><img src="/./week1907.jpg" alt="Alt text"></p>
<p>你已经知道ReactiveCocoa 框架如何给UIKit标准控件添加属性和方法。在此之前，你是用的是<code>rac_textSignal</code>，它在text改变的时候提交事件。为了处理事件，你需要另一种方法：    <code>rac_signalForControEvents</code>.</p>
<p>回到<code>RWViewController.m</code>，在viewDidload方法最后添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[self.signInButton</span><br><span class="line">   rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">   subscribeNext:^(id x) &#123;</span><br><span class="line">     NSLog(@&quot;button clicked&quot;);</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的代码从Button的<code>UIControlEventTouchUpInside</code>事件创建了一个的信号，并添加订阅，以便每次该事件发生的时候都会打印日志。</p>
<p>运行程序，当username和password有效的时候，点击该button, 查看控制台输出日志:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2013-12-28 08:05:10.816 RWReactivePlayground[18203:a0b] button clicked</span><br><span class="line">2013-12-28 08:05:11.675 RWReactivePlayground[18203:a0b] button clicked</span><br><span class="line">2013-12-28 08:05:12.605 RWReactivePlayground[18203:a0b] button clicked</span><br><span class="line">2013-12-28 08:05:12.766 RWReactivePlayground[18203:a0b] button clicked</span><br><span class="line">2013-12-28 08:05:12.917 RWReactivePlayground[18203:a0b] button clicked</span><br></pre></td></tr></table></figure>
<p>现在按钮有了点击事件的信号，下一步是将此与登录过程本身关联起来。这带来一些问题，但是没关系，你并不介意这些问题，对吗？ 打开<code>RWDummySigInService.h</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef void (^RWSignInResponse)(BOOL);</span><br><span class="line"></span><br><span class="line">@interface RWDummySignInService : NSObject</span><br><span class="line"></span><br><span class="line">- (void)signInWithUsername:(NSString *)username</span><br><span class="line">                  password:(NSString *)password </span><br><span class="line">                  complete:(RWSignInResponse)completeBlock;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该接口将<code>username</code>、<code>password</code>和<code>completeBlock</code>作为参数，当登录成功或者失败的时候执行<code>completeBlock</code>。你可以直接在button的<code>subscribeNext:</code>的block中调用该接口，为什么你能这么做呢？因为这种异步的、基于事件的行为，对ReactiveCocoa来说就是家常便饭。</p>
<blockquote>
<p>Note: 为了简单期间，本教程使用的简单的虚拟服务，这样就不依赖任何外部的API。但是现在有一个非常现实的问题，怎么使用未用信号表示的API。</p>
</blockquote>
<h4 id="Creating-Signals-创建信号"><a href="#Creating-Signals-创建信号" class="headerlink" title="Creating Signals (创建信号)"></a>Creating Signals (创建信号)</h4><p>幸运的是，将现有的异步API调整为信号相当容易。首先移除<code>signInButtonTouched:</code>方法，该方法将被其他逻辑所取代。<br>在<code>RWViewController.m</code>中添加下面的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-(RACSignal *)signInSignal &#123;</span><br><span class="line">  return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [self.signInService</span><br><span class="line">     signInWithUsername:self.usernameTextField.text</span><br><span class="line">     password:self.passwordTextField.text</span><br><span class="line">     complete:^(BOOL success) &#123;</span><br><span class="line">       [subscriber sendNext:@(success)];</span><br><span class="line">       [subscriber sendCompleted];</span><br><span class="line">     &#125;];</span><br><span class="line">    return nil;</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的方法创建了使用当前的username和password登录的信号，现在将其进行拆解：</p>
<p>上面的代码使用<code>RACSignal</code>中的<code>createSignal:</code>方法创建信号，该方法的参数是一个Block，用来描述该信号，且该Block只有一个参数。当信号有订阅者的时候，该Block中的代码将会执行。</p>
<p>传递给该Block的是一个<code>subscriber</code>实例，该实例遵守<code>RACSubscriber</code>协议，该协议中有你用来发出事件的方法，你可以发送任意个数的<code>next</code>事件,这些事件会因为<code>error</code>或者<code>complete</code>事件结束。本教程中，将会发送一个<code>next</code>事件来显示是否登录成功或者失败，然后发送    <code>comlete</code>事件结束。</p>
<p>这个Block的返回值是一个    <code>RACDisposable</code>对象，它允许你执行取消或者取消订阅的时候可能需要的任何清理工作。此信号因为没有任何清理需要，所以直接返回<code>nil</code>;</p>
<p>正如你所看到的，在信号中包装异步的API非常的简单。</p>
<p>现在我们来利用这个信号，将下面的代码添加到viewDidload的最后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[[self.signInButton</span><br><span class="line">   rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">   map:^id(id x) &#123;</span><br><span class="line">     return [self signInSignal];</span><br><span class="line">   &#125;]</span><br><span class="line">   subscribeNext:^(id x) &#123;</span><br><span class="line">     NSLog(@&quot;Sign in result: %@&quot;, x);</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的代码通过<code>map</code>操作符将登录信号转换为登录信号，订阅者只打印结果。</p>
<p>直接运行该代码，然后点击<code>Sign In</code>Button，查看XCode的控制台打印，将会看到下面的结果,该结果也许和你想象的不太一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2014-01-08 21:00:25.919 RWReactivePlayground[33818:a0b] Sign in result:</span><br><span class="line">                                   &lt;RACDynamicSignal: 0xa068a00&gt; name: +createSignal:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>subscribeNext:</code>block传递的是整个信号，而不是登录信号的结果。</p>
<p>来看下这张图：<br><img src="/./week1908.png" alt="Alt text"></p>
<p>当你点击button的时候，<code>rac_signallForControlEvents</code>发出一个<code>next</code>事件，然后<code>map</code>将创建并返回登录信号，这意味着下面的管道步骤接收的是RACSignal。这就是你在<code>subscribeNext:</code>中观察到的内容。</p>
<p>上面中情况称为信号中的信号，换言之是包含内部信号的外部信号。如果你想的话，你可以在外部信号的    <code>subscribeNext:</code>中订阅内部信号。但是这样做会导致嵌套混乱！幸运的是，这是一个常见的问题，ReactiveCocoa已经针对这种情况做好了准备;</p>
<h4 id="信号中的信号"><a href="#信号中的信号" class="headerlink" title="信号中的信号"></a>信号中的信号</h4><p>此问题的解决步骤非常的简单，只需将<code>map</code>函数改成<code>flattenMap</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[[self.signInButton</span><br><span class="line">   rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">   flattenMap:^id(id x) &#123;</span><br><span class="line">     return [self signInSignal];</span><br><span class="line">   &#125;]</span><br><span class="line">   subscribeNext:^(id x) &#123;</span><br><span class="line">     NSLog(@&quot;Sign in result: %@&quot;, x);</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段代码同样是将按钮的<code>点击信号</code>映射为<code>登录信号</code>,但是<code>flattens</code>可以将事件从内部信号发送到外部信号。</p>
<p>运行代码，看一下Xcode的控制台：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2013-12-28 18:20:08.156 RWReactivePlayground[22993:a0b] Sign in result: 0</span><br><span class="line">2013-12-28 18:25:50.927 RWReactivePlayground[22993:a0b] Sign in result: 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在这个管道正在做的就是你想要的了，最后一步就是在<code>subscribeNext</code>中添加相关的逻辑，以在登录成功之后执行所需的导航。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[[[self.signInButton</span><br><span class="line">  rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">  flattenMap:^id(id x) &#123;</span><br><span class="line">    return [self signInSignal];</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(NSNumber *signedIn) &#123;</span><br><span class="line">    BOOL success = [signedIn boolValue];</span><br><span class="line">    self.signInFailureText.hidden = success;</span><br><span class="line">    if (success) &#123;</span><br><span class="line">      [self performSegueWithIdentifier:@&quot;signInSuccess&quot; sender:self];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行程序：<br><img src="/./week1909.jpg" alt="Alt text"></p>
<p>你是否注意到当前的应用程序存在一个小的用户体验的问题？ 当登录服务验证提供的凭据时，应禁用登录按钮。这样可以防止用户重复相同的登录。此外，如果出现登录尝试失败，当用户再次尝试登录时，错误消息应隐藏。</p>
<p>但是，如何将此逻辑添加到当前管道？更改按钮的<code>enable</code>状态不是<code>transformation</code>、<code>filter</code>或到目前为止遇到的任何其他概念。其实，它被称为<code>副作用</code>或<code>管道中next事件发生时执行的逻辑</code>，它实际上不会更改事件本身。</p>
<h4 id="Adding-side-effects（添加副作用）"><a href="#Adding-side-effects（添加副作用）" class="headerlink" title="Adding side-effects（添加副作用）"></a>Adding side-effects（添加副作用）</h4><p>用下面的代码取代当前的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[[[[self.signInButton</span><br><span class="line">   rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">   doNext:^(id x) &#123;</span><br><span class="line">     self.signInButton.enabled = NO;</span><br><span class="line">     self.signInFailureText.hidden = YES;</span><br><span class="line">   &#125;]</span><br><span class="line">   flattenMap:^id(id x) &#123;</span><br><span class="line">     return [self signInSignal];</span><br><span class="line">   &#125;]</span><br><span class="line">   subscribeNext:^(NSNumber *signedIn) &#123;</span><br><span class="line">     self.signInButton.enabled = YES;</span><br><span class="line">     BOOL success = [signedIn boolValue];</span><br><span class="line">     self.signInFailureText.hidden = success;</span><br><span class="line">     if (success) &#123;</span><br><span class="line">       [self performSegueWithIdentifier:@&quot;signInSuccess&quot; sender:self];</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可以看到上面如何添加 <code>doNext：</code>,在按钮触摸事件创建后立即向管道添加该步骤。请注意，    <code>doNext：</code> 块没有返回值，因为它是副作用，它使事件本身保持不变。</p>
<p>上面的 <code>doNext：</code> 块将按钮的属性设置为 NO，并隐藏失败文本。当订阅<code>Next：</code>块的时候重新启用按钮，并根据登录结果显示或隐藏失败文本。</p>
<p><img src="/./week1910.png" alt="Alt text"></p>
<p>运行应用程序以确认登录按钮按预期启用和禁用</p>
<p>现在，你的工作就完成了 – 应用程序现在完全是Reactive状态。</p>
<blockquote>
<p>Note: 当异步事件正在进行的时候禁用button是一个常见的问题，如果ReacticeCocoa中遍布这种处理就会显得非常混乱。<code>RACCommand</code> 封装了这个概念，并具有<code>enabled</code>信号，允许您将Button的<code>enable</code>属性连接到信号, 可能你需要尝试该类。</p>
</blockquote>
<p>####结论</p>
<p>希望本教程已经给你一个良好的基础，这将有助于你在自己的应用程序中使用ReactiveCocoa框架。熟悉这些概念可能需要多加练习，但与任何语言或程序一样，一旦你找到它的窍门，它真的很简单。ReactiveCocoa的核心是信号，它们只不过是事件流。还有什么比这更简单的呢？</p>
<p>对于ReactiveCocoa，我发现的有趣的事情之一是有许多方法可以解决同样的问题。你可以通过这个应用程序练习，通过调整信号和管道，以更改它们拆分和组合的方式。</p>
<p>ReactiveCocoa的主要目标是使代码更简洁、更易于理解。就个人而言，我发现，如果应用程序的逻辑表示为清晰的管道，使用流畅的语法，则更容易理解应用程序的作用。</p>
<p>在本教程系列的<a target="_blank" rel="noopener" href="https://www.raywenderlich.com/?p=62796">第二部分中</a>，你将了解更高级的主题，如错误处理以及如何管理在不同线程上执行的代码。</p>
<h3 id="Part-03-原文"><a href="#Part-03-原文" class="headerlink" title="Part-03 原文"></a>Part-03 原文</h3><p><a target="_blank" rel="noopener" href="https://www.raywenderlich.com/2493-reactivecocoa-tutorial-the-definitive-introduction-part-1-2">ReactiveCocoa Tutorial – The Definitive Introduction: Part 1&#x2F;2</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://iamlay.com/2020/05/10/week19/" data-id="clfj8cp2x002ifbf3ganucck3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-week17" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/26/week17/" class="article-date">
  <time datetime="2020-04-26T03:52:04.000Z" itemprop="datePublished">2020-04-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/26/week17/">以技术之名周报05#ipa包“瘦身”| 2020-04-26</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h3><blockquote>
<p>随着App版本的不断迭代，安装包会越来越大。安装包的大小是非常影响用户体验的。在推广App的时候，如果安装包很大，需要花费很多的时间来下载，会劝退很多用户。所以，我们应当使安装包尽量小。</p>
</blockquote>
<h3 id="Part01-瘦身方向"><a href="#Part01-瘦身方向" class="headerlink" title="Part01 - 瘦身方向"></a>Part01 - 瘦身方向</h3><h4 id="安装包组成"><a href="#安装包组成" class="headerlink" title="安装包组成"></a>安装包组成</h4><p>通过将导出的ipa包，用<code>归档工具</code>解压，在解压出的<code>payload</code>文件夹中得到App文件,查看App包含的内容，我们可以发现该文件主要包含以下内容：</p>
<ol>
<li>Exectutable-可执行文件</li>
<li>Resources:资源文件<br>-  图片资源（Assets.car&#x2F;bundle&#x2F;png&#x2F;jpg）<br>-  音&#x2F;视频资源（mp&#x2F;mp4）<br>-  静态网页资源：html&#x2F;css&#x2F;js<br>-  其他：文本&#x2F;字体&#x2F;证书等</li>
<li>Framework:<br>- SwiftSupport: libSwiftxxx 等一系列 Swift 库<br>- 其他依赖库：Embeded Framework</li>
<li>Plugins: Application Extensions<br>- appex：其组成大致与 ipa 包组成一致</li>
</ol>
<h4 id="安装包优化分析"><a href="#安装包优化分析" class="headerlink" title="安装包优化分析"></a>安装包优化分析</h4><p> 在安装包中，可执行文件、图片资源和动态库占比较大，所以我们优化的重点就是这三个方向。</p>
<p> <img src="/week1701.png"></p>
<h3 id="Part02-瘦身实施"><a href="#Part02-瘦身实施" class="headerlink" title="Part02 - 瘦身实施"></a>Part02 - 瘦身实施</h3><h4 id="图片资源优化"><a href="#图片资源优化" class="headerlink" title="图片资源优化"></a>图片资源优化</h4><p>对大部分的App来讲，占比最大资源文件应该就是图片资源，所以资源文件优化的重点就是图片资源的优化。图片资源的优化可以从下面几个方向来进行。</p>
<h5 id="1⃣️️将部分图片资源放到服务器上"><a href="#1⃣️️将部分图片资源放到服务器上" class="headerlink" title="1⃣️️将部分图片资源放到服务器上"></a>1⃣️️将部分图片资源放到服务器上</h5><p>将所有的图片资源都打到安装包中其实是不必要的，反而会造成安装包极速的增大，资源应该是按需加载的。除了一些常用的图片资源和一些如果放在线上非常影响用户体验的图片，其他的图片都应该放在资源服务器上，做好相应的图片缓存策略。</p>
<h5 id="2⃣️清理没用的图片资源"><a href="#2⃣️清理没用的图片资源" class="headerlink" title="2⃣️清理没用的图片资源"></a>2⃣️清理没用的图片资源</h5><p>随着版本的迭代，之前导入的一些图片资源已经不再使用，要做到及时的清理没用的图片资源。<a target="_blank" rel="noopener" href="https://github.com/tinymind/LSUnusedResources">LSUnusedResources </a>是一款非常不错的无用图片查找工具，<a target="_blank" rel="noopener" href="https://github.com/tinymind/LSUnusedResources">LSUnusedResources </a>的思路是，先获取图片文件(imageset, jpg, png, gif)集合A，然后搜索代码文件中所有字符串名称得到B，然后从A集合中排除集合B就得到未使用的图片资源。</p>
<h5 id="3⃣️图片资源压缩"><a href="#3⃣️图片资源压缩" class="headerlink" title="3⃣️图片资源压缩"></a>3⃣️图片资源压缩</h5><p>可以使用<a target="_blank" rel="noopener" href="https://github.com/ImageOptim/ImageOptim">ImageOptim</a>，通过优化压缩参数，移除无用的文件元数据和不必要的颜色配置来实现图片的无损压缩。我们UI切图使用的是蓝湖，蓝湖也支持图片压缩，如果没有使用过的同学可以尝试。</p>
<h5 id="4⃣️iconfont"><a href="#4⃣️iconfont" class="headerlink" title="4⃣️iconfont"></a>4⃣️iconfont</h5><p>即使经过了图片转下载，无用图片删除，但是工程中的图片数量还是极为可观，其中各种各样的icon图标占了不少的数量。为了进一步减少图片数量，可以使用<code>iconfont</code>方案， <code>iconfont</code>优点：</p>
<ul>
<li>矢量，缩放不失真</li>
<li>可以设置颜色</li>
<li>接入成本低，不需要引入额外的类库</li>
</ul>
<p><code>iconfont </code>可以解决因为icon大小，颜色不同而重新切图的窘境。<code>iconfont</code>是一个能减少图片数量的好方案。</p>
<h4 id="可执行文件-Mach-O-优化"><a href="#可执行文件-Mach-O-优化" class="headerlink" title="可执行文件(Mach-O)优化"></a>可执行文件(Mach-O)优化</h4><h5 id="1⃣️LinkMap文件"><a href="#1⃣️LinkMap文件" class="headerlink" title="1⃣️LinkMap文件"></a>1⃣️LinkMap文件</h5><p>但是通过<code>MachOView</code>，是不可以查看每个静态文件喝每个.o文件的大小，所以我们需要想办法量化文件的大小,我们可以通过分析<code>LinkMap</code>文件做到。</p>
<p><code>LinkMap</code>文件是Xcode产生可执行文件的同时生成的链接信息，用来描述可执行文件的构造成分，包括代码段（__TEXT）和数据段（__DATA）的分布情况，可以根据这些信息进行针对性的优化。</p>
<ul>
<li>LinkMap文件获取：</li>
</ul>
<ol>
<li>设置<code>Project-&gt;Build Settings-&gt;Write Link Map File</code>为<code>YES</code></li>
<li>设置<code>Project-&gt;Build Settings-&gt;Path to Link Map File</code>为LinkMap文件的输出路径</li>
</ol>
<ul>
<li>LinkMap文件分析：</li>
</ul>
<p> 可以使用<a target="_blank" rel="noopener" href="https://github.com/huanxsd/LinkMap">LinkMap - LinkMap.txt 文件解析工具</a>分析每个类或者静态库的大小。通过查看LinkMap文件，各个静态库和文件的大小一目了然。</p>
<p>  <img src="/week1702.png" alt="Alt text"></p>
<p> 1、 在选用三方库的时候，尽量使用占用内存比较小的三方库，及时的移除不再使用的三方库。<br>2、分析占用内存比较大的类，删除类中没用的代码，减少冗余，保证用最简代码实现相应的功能，提升代码的复用性。</p>
<p><code>LinkMap</code>可以在宏观上获取需要优化的部分，但是微观上，哪些是无用的类和方法，需要我们在    <code>Mach-O</code>层面进行分析，可以使用<a target="_blank" rel="noopener" href="https://github.com/fangshufeng/MachOView">MachOView </a>对<code>Mach-O</code>文件进行分析。可以通过阅读<a target="_blank" rel="noopener" href="http://hawk0620.github.io/blog/2018/03/22/study-mach-o-file/">这篇文章</a>探秘<code>Mach-O</code>。 下面这张图是<code>MachOView</code>查看<code>Mach-O</code>文件的截图：</p>
<p><img src="/week1703.png" alt="Alt text"></p>
<p>大家可以阅读<a target="_blank" rel="noopener" href="https://juejin.im/post/5d5d1a92e51d45620923886a">:删除无用的类</a>进行实践</p>
<h5 id="2⃣️尽量不要使用OC和Swift混编"><a href="#2⃣️尽量不要使用OC和Swift混编" class="headerlink" title="2⃣️尽量不要使用OC和Swift混编"></a>2⃣️尽量不要使用OC和Swift混编</h5><p>OC和Swift混编的时候，因为需要一些静态库的支持，会造成安装包急剧增大。所以，尽量选择一种语言开发，不要采用混编的方式。<br><img src="/week1704.png" alt="Alt text"></p>
<h5 id="3⃣️代码瘦身"><a href="#3⃣️代码瘦身" class="headerlink" title="3⃣️代码瘦身"></a>3⃣️代码瘦身</h5><p>可以使用<a target="_blank" rel="noopener" href="https://www.jetbrains.com/objc/">AppCode</a>进行代码的静态检查。<a target="_blank" rel="noopener" href="https://www.jetbrains.com/objc/">AppCode</a> 提供了非常强大的代码静态检查工具，使用<code>Inspect Code</code>，可以找到很多代码优化的地方:主要包括删除不用的类，不用的函数，重复的代码等。<br><img src="/week1705.png" alt="Alt text"></p>
<h4 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h4><p>Xcode 支持编译器层面的一些优化优化选项，可以让我们介于更快的编译速度、更小的二进制大小和更快的执行速度之间自由选择想要进行的优化粒度。</p>
<h5 id="1⃣️BitCode"><a href="#1⃣️BitCode" class="headerlink" title="1⃣️BitCode"></a>1⃣️BitCode</h5><p>可以在<code> Xcode Target -&gt; Build Settings -&gt; Enable Bitcode</code> 中打开 bitcode 选项</p>
<p>Bitcode可以作为中间产物一起提交AppStore。包含Bitcode配置的程序将会在AppStore上被编译和链接。Bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到AppStore上。</p>
<p>在打包时，如果一些三方的依赖库没有开启 bitcode，或者开启了但是没有在最终引用的链接库中带有 bitcode，那么整个工程就无法用 bitcode 来编译了。</p>
<h3 id="Part03-参考"><a href="#Part03-参考" class="headerlink" title="Part03- 参考"></a>Part03- 参考</h3><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5cbb3f9151882529e5627ece">App瘦身小记</a><br><a target="_blank" rel="noopener" href="http://www.cocoachina.com/articles/859032">京东商城iOS App瘦身实践</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c94dedef90b7">APP安装包瘦身实践</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/86317689">iOS开发：Archive、ipa 和 App 包瘦身</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/5e969d816fb9a03c60188229?utm_source=gold_browser_extension">APP体积优化</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://iamlay.com/2020/04/26/week17/" data-id="clfj8cp2x002hfbf32hnc9iw3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%91%A8%E6%8A%A5/">周报</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%AB%99/">网站</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ChatGPT/" rel="tag">ChatGPT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/ChatGPT/" style="font-size: 10px;">ChatGPT</a> <a href="/tags/%E5%8E%9F%E5%88%9B/" style="font-size: 20px;">原创</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 10px;">翻译</a> <a href="/tags/%E8%BD%AC%E8%BD%BD/" style="font-size: 15px;">转载</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/03/22/GPTRegister/">ChatGPT保姆级注册教程</a>
          </li>
        
          <li>
            <a href="/2022/10/16/PDFFindGuide/">PDF查找指导文档</a>
          </li>
        
          <li>
            <a href="/2022/04/17/MacRecommannd/">以技术之名周报10#｜推荐：Mac用户必备网站和App｜2022-04-17</a>
          </li>
        
          <li>
            <a href="/2022/04/11/EBookFind/">以技术之名周报09#｜如何高效的查找一本电子书｜2022-04-11</a>
          </li>
        
          <li>
            <a href="/2020/08/28/week2020-36/">以技术之名周报08#| Swift代码规范| 2020-08-28</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Ray<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>